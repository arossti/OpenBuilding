<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Energy Flow Sankey Diagram</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    /* Base Layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0 auto;
      max-width: 1800px;
      padding: 20px;
      min-width: 400px;
    }

    /* Core Layout Components */
    .container { 
      display: flex; 
      gap: 10px; 
      margin-top: 10px; 
      flex-direction: column; 
    }
    
    .button-row { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      padding: 10px 0; 
      border-bottom: 1px solid #eee; 
    }
    
    .status-row { 
      min-height: 24px; 
      padding: 4px 0; 
    }
    
    .file-input-group { 
      display: flex; 
      align-items: center; 
      gap: 8px; 
    }
    
    .diagram-container { 
      flex: 0 0 auto; 
      width: 100%; 
    }
    
    .controls-container {
      flex: 1 1 400px;
      min-width: 400px;
      background: #fff;
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    /* Sankey Elements */
    .node {
      stroke: #000;
      stroke-width: 1px;
      cursor: pointer;
    }
    
    .link {
      fill: none;
      stroke-opacity: 0.7;
      transition: stroke-opacity 0.2s;
      cursor: pointer;
    }
    
    .link:hover { 
      stroke-opacity: 0.9; 
    }
    
    .node-label {
      font-size: 11px;
      fill: black;
      pointer-events: none;
      font-weight: 500;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      padding: 12px;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid #ddd;
      border-radius: 6px;
      pointer-events: none;
      font-size: 12px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      max-width: 300px;
      line-height: 1.4;
      z-index: 1000;
    }
    
    .tooltip-title {
      font-weight: 600;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    
    .tooltip-value { 
      color: #666; 
      font-size: 11px; 
    }
    
    .tooltip-flow {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
    }

    /* Controls */
    .controls-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    
    .controls-table th,
    .controls-table td {
      padding: 1px 8px;
      border: 1px solid #ddd;
      text-align: left;
    }
    
    .controls-table th:first-child { 
      width: 210px; 
      min-width: 210px; 
    }
    
    .controls-table th:nth-child(2) { 
      width: 50px; 
    }
    
    .controls-table th {
      background-color: #f5f5f5;
      position: sticky;
      top: 0;
      z-index: 1;
      font-weight: 600;
    }

    /* UI Elements */
    .slider-cell { 
      display: flex; 
      align-items: center; 
      gap: 5px; 
    }
    
    input[type="range"] { 
      width: 100px; 
      accent-color: #666; 
    }
    
    #widthMultiplier { 
      height: 20px; 
      margin: 0; 
    }
    
    .value-display {
      min-width: 70px;
      text-align: right;
      font-size: 11px;
      font-weight: 500;
      color: #333;
    }

    /* Buttons */
    button {
      padding: 6px 12px;
      cursor: pointer;
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
      transition: all 0.2s;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    button:hover {
      background-color: #e5e5e5;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* Special Buttons */
    #importButton { 
      background-color: #2196F3; 
      color: white; 
      border: none; 
    }
    
    #importButton:hover { 
      background-color: #1976D2; 
    }
    
    #applyButton { 
      background-color: #4CAF50; 
      color: white; 
      border: none; 
    }
    
    #applyButton:hover { 
      background-color: #45a049; 
    }
    
    #applyButton:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
      transform: none;
    }

    /* Width Toggle */
    .width-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 3px 12px;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      height: 23px;
    }
    
    .width-toggle label { 
      font-size: 12px; 
      color: #333; 
    }

    /* Status Indicators */
    #fileName { 
      color: #666; 
      font-size: 12px; 
      margin-left: 8px; 
    }
    
    #statusMessage { 
      font-size: 12px; 
      padding: 4px 8px; 
      border-radius: 4px; 
    }
    
    .status-success { 
      color: #4CAF50; 
      background-color: #E8F5E9; 
    }
    
    .status-error { 
      color: #f44336; 
      background-color: #FFEBEE; 
    }
    
    .status-pending { 
      color: #2196F3; 
      background-color: #E3F2FD; 
    }

    /* Layout Elements */
    h3, h4 { 
      margin: 0; 
      color: #333; 
    }
    
    .tables-container { 
      display: flex; 
      gap: 20px; 
      margin-top: 15px; 
    }
    
    .table-section { 
      flex: 1; 
      min-width: 0; 
    }

    /* Responsive */
    @media (max-width: 800px) {
      .tables-container { 
        flex-direction: column; 
      }
    }
  </style>
</head>
<body>
  <div class="button-row">
    <div class="file-input-group">
      <input type="file" id="csvFile" accept=".xlsx" style="display: none">
      <button id="importButton">Import</button>
      <span id="fileName"></span>
      <button id="applyButton" style="display: none;">Apply Changes</button>
    </div>
    <button id="toggleSpacingButton">Show as Energy Balance</button>
    <div class="width-toggle">
      <label for="widthMultiplier">Node Width:</label>
      <input type="range" id="widthMultiplier" min="100" max="800" value="100" step="10">
      <span id="widthValue">100%</span>
    </div>
    <button id="resetButton">Reset Values</button>
    <button id="toggleEmissionsButton" style="background-color: #808080; color: white;">Show Emissions</button>
    <button id="heatSourceButton" style="background-color: #A9D7F2; color: white;">HP/Electric Heat+SHW</button>
  </div>

  <div class="status-row">
    <span id="statusMessage"></span>
  </div>

  <div class="container">
    <div class="diagram-container">
      <svg id="sankey" height="600"></svg>
      <div id="tooltip" class="tooltip" style="display: none;"></div>
    </div>

    <div class="controls-container">
      <h4>Flow Control Panel</h4>
      
      <div class="cost-calculator" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e9ecef;">
        <div style="display: flex; flex-wrap: wrap; gap: 20px;">
          <!-- Energy Cost Section -->
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="energyCost" style="font-size: 12px;">Electricity $/kWh:</label>
            <input type="number" id="energyCost" min="0" step="0.01" value="0.12" 
                   style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            <span style="font-size: 12px;">
              <span style="font-weight: bold;">Total:</span> $<span id="totalEnergyCost">0.00</span>
            </span>
          </div>

          <!-- Grid Intensity Section -->
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="gridIntensity" style="font-size: 12px;">Grid Intensity (g/kWh):</label>
            <input type="number" id="gridIntensity" min="0" step="0.01" value="67.00" 
                   style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            <span style="font-size: 12px;">
              <span style="font-weight: bold;">Total:</span> <span id="totalEmissions">0.00</span> MTCO2e/yr
            </span>
          </div>

          <!-- Efficiency Settings -->
          <div style="display: flex; flex-wrap: wrap; gap: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="copHeating" style="font-size: 12px;">
                <span id="copHeatingLabel">COP Heating</span>:
              </label>
              <input type="number" id="copHeating" min="0.1" max="20" step="0.1" value="3.0" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="copCooling" style="font-size: 12px;">COP Cooling:</label>
              <input type="number" id="copCooling" min="0.1" max="20" step="0.1" value="2.0" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="mvhrEfficiency" style="font-size: 12px;">MVHR Efficiency:</label>
              <input type="number" id="mvhrEfficiency" min="0" max="1" step="0.01" value="0.80" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="dwhrEfficiency" style="font-size: 12px;">DWHR Efficiency:</label>
              <input type="number" id="dwhrEfficiency" min="0" max="0.75" step="0.01" value="0.50" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
          </div>
        </div>
      </div>

      <div class="tables-container">
        <div class="table-section">
          <table class="controls-table">
            <thead>
              <tr>
                <th>Energy Supplied</th>
                <th style="width: 50px;">Value</th>
                <th style="width: 120px;">Adjust</th>
              </tr>
            </thead>
            <tbody id="gainsControlsBody"></tbody>
          </table>
        </div>

        <div class="table-section">
          <table class="controls-table">
            <thead>
              <tr>
                <th>Energy Lost</th>
                <th style="width: 50px;">Value</th>
                <th style="width: 120px;">Adjust</th>
              </tr>
            </thead>
            <tbody id="lossesControlsBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
	
<script>
// Core Configuration
const CONFIG = {
  VALUE_LIMITS: {
    COP_HEATING: { min: 0.1, max: 20, step: 0.1, default: 3.0 },
    COP_COOLING: { min: 0.1, max: 20, step: 0.1, default: 4.0 },
    MVHR: { min: 0, max: 1, step: 0.01, default: 0.80 },
    DWHR: { min: 0, max: 0.75, step: 0.01, default: 0.50 }
  },
  EMISSIONS: {
    GAS_INTENSITY: 1921,  // gCO2e/m3
    GAS_ENERGY_DENSITY: 10.36  // ekWh/m3
  }
};

// Excel Mapping Configuration
const EXCEL_MAPPING = {
  SHEETS: {
    ENERGY_BALANCE: "ENERGY BALANCE",
    REPORT: "REPORT"
  },
  NODE_VALUES: {
    // Sources to Building
    "G.1.1 Occupant Gains": "ENERGY BALANCE!D5",
    "G.3.1 Plug Light Equipment": "ENERGY BALANCE!D6",
    "W.2.D.N SHW Net Demand": "ENERGY BALANCE!D7",
    "G.8.1 Windows N": "ENERGY BALANCE!D9",
    "G.8.2 Windows E": "ENERGY BALANCE!D10",
    "G.8.3 Windows S": "ENERGY BALANCE!D11",
    "G.8.4 Windows W": "ENERGY BALANCE!D12",
    "M.2.2 Sink (Air/Ground)": "ENERGY BALANCE!D17",
    "M.2.2 Energy Input": "ENERGY BALANCE!D18",
    "Heating Demand": "ENERGY BALANCE!D24",
    // TEDI Losses
    "B.4 Roof": "ENERGY BALANCE!F5",
    "B.5 Walls Ae": "ENERGY BALANCE!F6",
    "B.6 Floor Exposed": "ENERGY BALANCE!F7",
    "B.7 Doors": "ENERGY BALANCE!F8",
    "B.8.1 Windows N": "ENERGY BALANCE!F9",
    "B.8.2 Windows E": "ENERGY BALANCE!F10",
    "B.8.3 Windows S": "ENERGY BALANCE!F11",
    "B.8.4 Windows W": "ENERGY BALANCE!F12",
    "B.10 Floor Slab": "ENERGY BALANCE!F14",
    "B.13.2 TB Penalty": "ENERGY BALANCE!F15",
    "B.19.5 Air Leakage": "ENERGY BALANCE!F16",
    "V.3.5 Unrecovered Ventilation": "ENERGY BALANCE!F17",
    "W.2.W SHW Wasted": "ENERGY BALANCE!F18",
    "G.7 Unusable Heating Gains": "ENERGY BALANCE!F19"
  },
  GLOBAL_VALUES: {
    "COPh": "REPORT!G118",
    "COPc": "REPORT!I118",
    "MVHR": "REPORT!D123",
    "DWHR": "REPORT!D45",
    "ProjectName": "REPORT!I14"
  }
};

// Initial Data Structure
const INITIAL_DATA = {
  nodes: [
    { name: "Building", color: "#4A96BA" },                         // [0] Central node
    { name: "G.1.1 Occupant Gains", color: "#FF8C00" },            // [1] Internal gains
    { name: "G.3.1 Plug Light Equipment", color: "#A5D3ED" },      // [2] Equipment gains
    { name: "W.2.D.N SHW Net Demand", color: "#BE343D" },          // [3] Hot water demand
    { name: "G.8.1 Windows N", color: "#F9DF4B" },                 // [4] Solar N
    { name: "G.8.2 Windows E", color: "#F9DF4B" },                 // [5] Solar E
    { name: "G.8.3 Windows S", color: "#F9DF4B" },                 // [6] Solar S
    { name: "G.8.4 Windows W", color: "#F9DF4B" },                 // [7] Solar W
    { name: "M.2.2 Sink (Air/Ground)", color: "#D4B26F" },         // [8] Heat pump source
    { name: "M.2.2 Energy Input", color: "#A9D7F2" },              // [9] Heat pump input
    { name: "Heating Demand", color: "#BFA586" },                  // [10] Heating system
    { name: "B.4 Roof", color: "#8FAFA6" },                        // [11] Roof loss
    { name: "B.5 Walls Ae", color: "#8FAFA6" },                    // [12] Wall loss
    { name: "B.6 Floor Exposed", color: "#8FAFA6" },               // [13] Floor loss
    { name: "B.7 Doors", color: "#8FAFA6" },                       // [14] Door loss
    { name: "B.8.1 Windows N", color: "#F9DF4B" },                 // [15] Window N loss
    { name: "B.8.2 Windows E", color: "#F9DF4B" },                 // [16] Window E loss
    { name: "B.8.3 Windows S", color: "#F9DF4B" },                 // [17] Window S loss
    { name: "B.8.4 Windows W", color: "#F9DF4B" },                 // [18] Window W loss
    { name: "B.10 Floor Slab", color: "#8FAFA6" },                 // [19] Slab loss
    { name: "B.13.2 TB Penalty", color: "#8FAFA6" },               // [20] Thermal bridge
    { name: "B.19.5 Air Leakage", color: "#A4D3ED" },             // [21] Air leakage
    { name: "V.3.5 Unrecovered Ventilation", color: "#A5D3ED" },   // [22] Ventilation
    { name: "W.2.W SHW Wasted", color: "#BE343D" },               // [23] Hot water waste
    { name: "G.7 Unusable Heating Gains", color: "#FFA500" },      // [24] Excess heat
    { name: "TEDI", color: "#8FAFA6" },                           // [25] Total envelope
    { name: "E1 Scope 1 Emissions", color: "#808080" },           // [26] Direct emissions
    { name: "E2 Scope 2 Emissions", color: "#808080" }            // [27] Indirect emissions
  ],
  links: [
    { source: 1, target: 0, value: 12924.43 },    // Occupant gains
    { source: 2, target: 0, value: 13970.88 },    // Equipment gains
    { source: 3, target: 0, value: 3333.33 },     // Hot water demand
    { source: 4, target: 0, value: 137.55 },      // North solar
    { source: 5, target: 0, value: 4739.5 },      // East solar
    { source: 6, target: 0, value: 7427.70 },     // South solar
    { source: 7, target: 0, value: 1592.98 },     // West solar
    { source: 8, target: 10, value: 28866.25 },   // Source to heating
    { source: 9, target: 10, value: 10837.55 },   // Electric to heating
    { source: 10, target: 0, value: 39703.79 },   // Heat pump to building
    { source: 25, target: 11, value: 6152.64 },   // Roof
    { source: 25, target: 12, value: 0.00 },      // Walls
    { source: 25, target: 13, value: 0.00 },      // Floor
    { source: 25, target: 14, value: 101.95 },    // Doors
    { source: 25, target: 15, value: 10704.96 },  // Windows N
    { source: 25, target: 16, value: 6280.24 },   // Windows E
    { source: 25, target: 17, value: 10704.96 },  // Windows S
    { source: 25, target: 18, value: 6280.24 },   // Windows W
    { source: 25, target: 19, value: 5037.96 },   // Slab
    { source: 25, target: 20, value: 9032.2 },    // Thermal bridge
    { source: 25, target: 21, value: 4718.21 },   // Air leakage
    { source: 0, target: 22, value: 2570.04 },    // Ventilation loss
    { source: 0, target: 23, value: 3333.33 },    // Hot water waste
    { source: 0, target: 24, value: 19015.39 },   // Unusable gains
    { source: 0, target: 25, value: 58911.41 }    // Total envelope loss
  ]
};

// Global State Variables
let data = JSON.parse(JSON.stringify(INITIAL_DATA));
let originalData = JSON.parse(JSON.stringify(INITIAL_DATA));
let pendingImportData = null;
let spacingCollapsed = false;
let widthMultiplier = 1;
let showEmissions = false;
let isGasHeating = false;

// System State Variables
let COPh = 3.0;
let previousCOPh = 3.0;
let COPc = 4.0;
let MVHR = 0.80;
let DWHR = 0.50;
let HP = 0;
let M22D = 0;
let M22S = 0;
</script>
	
<script>
// Value State Class
class ValueState {
  constructor(config) {
    this._config = config;
    this._default = config.default;
    this._imported = null;
    this._userEdited = null;
    this._originalValue = null;
    this._validators = new Map([
      ['percentage', v => v >= 0 && v <= 1],
      ['positive', v => v > 0],
      ['range', v => v >= this._config.min && v <= this._config.max]
    ]);
  }

  get value() {
    return this._userEdited ?? this._imported ?? this._default;
  }

  get hasImported() {
    return this._imported !== null;
  }

  get isUserEdited() {
    return this._userEdited !== null;
  }

  setImported(value) {
    const normalized = this._normalize(value);
    if (this._validate(normalized)) {
      this._imported = normalized;
      this._originalValue = normalized; // Store original imported value
      this._userEdited = null;  // Clear user edits when importing
      return true;
    }
    return false;
  }

  setUserEdited(value) {
    const normalized = this._normalize(value);
    if (this._validate(normalized)) {
      this._userEdited = normalized;
      return true;
    }
    return false;
  }

  reset() {
    // Reset to imported value if exists, otherwise default
    this._userEdited = null;
    return this.value;
  }

  resetToDefault() {
    // Complete reset to initial default state
    this._imported = null;
    this._userEdited = null;
    this._originalValue = null;
    return this._default;
  }

  _normalize(value) {
    // Handle string inputs
    if (typeof value === 'string') {
      // Handle percentage strings
      if (value.endsWith('%')) {
        value = parseFloat(value) / 100;
      } else {
        value = parseFloat(value);
      }
    }

    // Handle values > 1 that should be percentages
    if (this._config.isPercentage && value > 1 && value <= 100) {
      value = value / 100;
    }

    // Apply any rounding rules
    if (this._config.precision !== undefined) {
      value = Number(value.toFixed(this._config.precision));
    }

    return value;
  }

  _validate(value) {
    if (isNaN(value)) return false;
    
    // Apply all relevant validators
    return Array.from(this._validators.entries())
      .filter(([key]) => this._config[key])
      .every(([_, validator]) => validator(value));
  }
}

// State Manager
const StateManager = {
  _states: new Map(),
  _listeners: new Map(),

  initialize() {
    // Initialize global value states
    this._states.set('copHeating', new ValueState({
      default: CONFIG.VALUE_LIMITS.COP_HEATING.default,
      min: CONFIG.VALUE_LIMITS.COP_HEATING.min,
      max: CONFIG.VALUE_LIMITS.COP_HEATING.max,
      precision: 1,
      positive: true,
      range: true
    }));

    this._states.set('copCooling', new ValueState({
      default: CONFIG.VALUE_LIMITS.COP_COOLING.default,
      min: CONFIG.VALUE_LIMITS.COP_COOLING.min,
      max: CONFIG.VALUE_LIMITS.COP_COOLING.max,
      precision: 1,
      positive: true,
      range: true
    }));

    this._states.set('mvhrEfficiency', new ValueState({
      default: CONFIG.VALUE_LIMITS.MVHR.default,
      min: CONFIG.VALUE_LIMITS.MVHR.min,
      max: CONFIG.VALUE_LIMITS.MVHR.max,
      precision: 2,
      isPercentage: true,
      range: true
    }));

    this._states.set('dwhrEfficiency', new ValueState({
      default: CONFIG.VALUE_LIMITS.DWHR.default,
      min: CONFIG.VALUE_LIMITS.DWHR.min,
      max: CONFIG.VALUE_LIMITS.DWHR.max,
      precision: 2,
      isPercentage: true,
      range: true
    }));
  },

  getValue(key) {
    return this._states.get(key)?.value ?? null;
  },

  setValue(key, value, type = 'user') {
    const state = this._states.get(key);
    if (!state) return false;

    const success = type === 'import' ? 
      state.setImported(value) : 
      state.setUserEdited(value);

    if (success) {
      this._notifyListeners(key, state.value);
      return true;
    }
    return false;
  },

  addListener(key, callback) {
    if (!this._listeners.has(key)) {
      this._listeners.set(key, new Set());
    }
    this._listeners.get(key).add(callback);
  },

  removeListener(key, callback) {
    this._listeners.get(key)?.delete(callback);
  },

  _notifyListeners(key, value) {
    this._listeners.get(key)?.forEach(callback => callback(value));
  },

  updateFromImport(importedData) {
    let success = true;
    const updates = new Map();

    Object.entries(importedData).forEach(([key, value]) => {
      if (this._states.has(key)) {
        const result = this.setValue(key, value, 'import');
        if (result) {
          updates.set(key, this.getValue(key));
        } else {
          success = false;
        }
      }
    });

    return {
      success,
      updates: Object.fromEntries(updates)
    };
  },

  reset() {
    this._states.forEach((state, key) => {
      state.reset();
      this._notifyListeners(key, state.value);
    });
  },

  resetToDefault() {
    this._states.forEach((state, key) => {
      state.resetToDefault();
      this._notifyListeners(key, state.value);
    });
  },

  getState(key) {
    return this._states.get(key);
  },

  getAllValues() {
    const values = {};
    this._states.forEach((state, key) => {
      values[key] = state.value;
    });
    return values;
  }
};

// Initialize the state manager
StateManager.initialize();
</script>

<script>
// Node Utilities
const NodeUtils = {
  findNodeIndex(name) {
    return data.nodes.findIndex(node => node.name === name);
  },

  getNodeByName(name) {
    return data.nodes.find(node => node.name === name);
  },

  getNodeIndex(node) {
    if (!node) return null;
    return typeof node === 'number' ? node : 
           typeof node === 'object' ? (node.index ?? data.nodes.indexOf(node)) : null;
  },

  getSourceNodeIndex(link) {
    return link?.source ? (
      typeof link.source === 'number' ? link.source :
      typeof link.source === 'object' ? (link.source.index ?? data.nodes.indexOf(link.source)) : null
    ) : null;
  },

  getTargetNodeIndex(link) {
    return link?.target ? (
      typeof link.target === 'number' ? link.target :
      typeof link.target === 'object' ? (link.target.index ?? data.nodes.indexOf(link.target)) : null
    ) : null;
  },

  ensureNodeReferences() {
    data.links.forEach(link => {
      if (typeof link.source === 'number') link.source = data.nodes[link.source];
      if (typeof link.target === 'number') link.target = data.nodes[link.target];
    });
  }
};

// Link Utilities
const LinkUtils = {
  findLink(sourceIndex, targetIndex) {
    return data.links.find(link => 
      NodeUtils.getSourceNodeIndex(link) === sourceIndex && 
      NodeUtils.getTargetNodeIndex(link) === targetIndex
    );
  },

  findLinkIndex(sourceIndex, targetIndex) {
    return data.links.findIndex(link => 
      NodeUtils.getSourceNodeIndex(link) === sourceIndex && 
      NodeUtils.getTargetNodeIndex(link) === targetIndex
    );
  },

  getLinkValue(sourceName, targetName) {
    const sourceIndex = NodeUtils.findNodeIndex(sourceName);
    const targetIndex = NodeUtils.findNodeIndex(targetName);
    const link = this.findLink(sourceIndex, targetIndex);
    return link ? link.value : 0;
  },

  updateLink(sourceIndex, targetIndex, newValue, silent = false) {
    const linkIndex = this.findLinkIndex(sourceIndex, targetIndex);
    if (linkIndex === -1) return false;

    const sourceName = data.nodes[sourceIndex].name;
    const targetName = data.nodes[targetIndex].name;
    
    // Enforce minimum value
    newValue = Math.max(0.1, newValue);
    
    // Update link value
    data.links[linkIndex].value = newValue;

    if (!silent) {
      // Update UI display if not silent
      const valueDisplay = document.querySelector(
        `.value-display[data-source="${sourceName}"][data-target="${targetName}"]`
      );
      if (valueDisplay) {
        valueDisplay.textContent = newValue.toFixed(1);
      }
    }

    return true;
  },

  updateLinkByNames(sourceName, targetName, newValue, silent = false) {
    const sourceIndex = NodeUtils.findNodeIndex(sourceName);
    const targetIndex = NodeUtils.findNodeIndex(targetName);
    return this.updateLink(sourceIndex, targetIndex, newValue, silent);
  }
};

// Data Manager
const DataManager = {
  _pendingChanges: new Map(),
  
  validateData(data) {
    const requiredFields = ['nodes', 'links'];
    const requiredNodeFields = ['name', 'color'];
    const requiredLinkFields = ['source', 'target', 'value'];
    
    // Check basic structure
    if (!requiredFields.every(field => field in data)) {
      throw new Error('Invalid data structure: missing required fields');
    }
    
    // Validate nodes
    if (!Array.isArray(data.nodes)) {
      throw new Error('Nodes must be an array');
    }
    
    data.nodes.forEach((node, index) => {
      if (!requiredNodeFields.every(field => field in node)) {
        throw new Error(`Node ${index} missing required fields`);
      }
    });
    
    // Validate links
    if (!Array.isArray(data.links)) {
      throw new Error('Links must be an array');
    }
    
    data.links.forEach((link, index) => {
      if (!requiredLinkFields.every(field => field in link)) {
        throw new Error(`Link ${index} missing required fields`);
      }
      
      // Validate source and target references
      const sourceIndex = typeof link.source === 'number' ? link.source : 
                         data.nodes.findIndex(n => n.name === link.source.name);
      const targetIndex = typeof link.target === 'number' ? link.target :
                         data.nodes.findIndex(n => n.name === link.target.name);
                         
      if (sourceIndex === -1 || targetIndex === -1) {
        throw new Error(`Link ${index} has invalid source or target reference`);
      }
      
      if (typeof link.value !== 'number' || link.value < 0) {
        throw new Error(`Link ${index} has invalid value`);
      }
    });
    
    return true;
  },

  queueChange(change) {
    const changeId = crypto.randomUUID();
    this._pendingChanges.set(changeId, change);
    return changeId;
  },

  applyChange(changeId) {
    const change = this._pendingChanges.get(changeId);
    if (!change) return false;

    try {
      change.apply();
      this._pendingChanges.delete(changeId);
      return true;
    } catch (error) {
      console.error('Error applying change:', error);
      return false;
    }
  },

  applyAllChanges() {
    let success = true;
    this._pendingChanges.forEach((change, changeId) => {
      if (!this.applyChange(changeId)) {
        success = false;
      }
    });
    this._pendingChanges.clear();
    return success;
  },

  revertChange(changeId) {
    this._pendingChanges.delete(changeId);
  },

  clearChanges() {
    this._pendingChanges.clear();
  },

  backup() {
    return {
      data: JSON.parse(JSON.stringify(data)),
      originalData: JSON.parse(JSON.stringify(originalData))
    };
  },

  restore(backup) {
    if (backup.data && backup.originalData) {
      data = backup.data;
      originalData = backup.originalData;
      NodeUtils.ensureNodeReferences();
      return true;
    }
    return false;
  },

  isCalculatedFlow(sourceName, targetName) {
    const calculatedFlows = [
      { source: "Heating Demand", target: "Building" },
      { source: "Building", target: "G.7 Unusable Heating Gains" },
      { source: "Building", target: "TEDI" }
    ];

    return calculatedFlows.some(flow => 
      flow.source === sourceName && flow.target === targetName
    );
  }
};
</script>

<script>
const EnergyCalculator = {
  calculateEnergyBalance() {
    // Calculate building inputs
    const buildingInputs = {
      G11: LinkUtils.getLinkValue("G.1.1 Occupant Gains", "Building"),
      G31: LinkUtils.getLinkValue("G.3.1 Plug Light Equipment", "Building"),
      W2DN: LinkUtils.getLinkValue("W.2.D.N SHW Net Demand", "Building"),
      G81: LinkUtils.getLinkValue("G.8.1 Windows N", "Building"),
      G82: LinkUtils.getLinkValue("G.8.2 Windows E", "Building"),
      G83: LinkUtils.getLinkValue("G.8.3 Windows S", "Building"),
      G84: LinkUtils.getLinkValue("G.8.4 Windows W", "Building")
    };

    // Calculate heat pump values
    HP = LinkUtils.getLinkValue("Heating Demand", "Building");
    M22D = isGasHeating ? HP : HP / StateManager.getValue('copHeating');
    M22S = isGasHeating ? 0 : HP - M22D;

    // Sum total building energy
    const BLDG = Object.values(buildingInputs).reduce((sum, val) => sum + val, 0) + HP;

    // Calculate TEDI components
    const tediComponents = {
      B4: LinkUtils.getLinkValue("TEDI", "B.4 Roof"),
      B5: LinkUtils.getLinkValue("TEDI", "B.5 Walls Ae"),
      B6: LinkUtils.getLinkValue("TEDI", "B.6 Floor Exposed"),
      B7: LinkUtils.getLinkValue("TEDI", "B.7 Doors"),
      B81: LinkUtils.getLinkValue("TEDI", "B.8.1 Windows N"),
      B82: LinkUtils.getLinkValue("TEDI", "B.8.2 Windows E"),
      B83: LinkUtils.getLinkValue("TEDI", "B.8.3 Windows S"),
      B84: LinkUtils.getLinkValue("TEDI", "B.8.4 Windows W"),
      B10: LinkUtils.getLinkValue("TEDI", "B.10 Floor Slab"),
      B132: LinkUtils.getLinkValue("TEDI", "B.13.2 TB Penalty"),
      B195: LinkUtils.getLinkValue("TEDI", "B.19.5 Air Leakage")
    };

    const TEDI = Object.values(tediComponents).reduce((sum, val) => sum + val, 0);

    // Building losses
    const V35 = LinkUtils.getLinkValue("Building", "V.3.5 Unrecovered Ventilation");
    const W2W = LinkUtils.getLinkValue("Building", "W.2.W SHW Wasted");
    const G7 = LinkUtils.getLinkValue("Building", "G.7 Unusable Heating Gains");

    const BLDG_LOSSES = TEDI + V35 + W2W + G7;

    return {
      BLDG,
      TEDI,
      BLDG_LOSSES,
      isBalanced: Math.abs(BLDG - BLDG_LOSSES) < 0.1
    };
  },

  updateBuildingBalance() {
    const buildingIndex = NodeUtils.findNodeIndex("Building");

    // Calculate total passive gains
    const passiveGains = [
      "G.1.1 Occupant Gains",
      "G.3.1 Plug Light Equipment",
      "W.2.D.N SHW Net Demand",
      "G.8.1 Windows N",
      "G.8.2 Windows E",
      "G.8.3 Windows S",
      "G.8.4 Windows W"
    ].reduce((sum, source) => {
      return sum + LinkUtils.getLinkValue(source, "Building");
    }, 0);

    // Calculate total losses
    const tediTotal = LinkUtils.getLinkValue("Building", "TEDI");
    const ventLoss = LinkUtils.getLinkValue("Building", "V.3.5 Unrecovered Ventilation");
    const dhwLoss = LinkUtils.getLinkValue("Building", "W.2.W SHW Wasted");
    const totalLosses = tediTotal + ventLoss + dhwLoss;

    // Calculate required heating
    const requiredHP = Math.max(0.1, totalLosses - passiveGains);
    HP = requiredHP;

    this.updateHeatPumpValues(requiredHP);

    // Calculate unusable gains
    const unusableGains = Math.max(0.1, passiveGains + requiredHP - totalLosses);
    LinkUtils.updateLink(
      buildingIndex,
      NodeUtils.findNodeIndex("G.7 Unusable Heating Gains"),
      unusableGains,
      true
    );
  },

  updateHeatPumpValues(requiredOutput) {
    const heatpumpIndex = NodeUtils.findNodeIndex("Heating Demand");
    const buildingIndex = NodeUtils.findNodeIndex("Building");
    const sinkNodeIndex = NodeUtils.findNodeIndex("M.2.2 Sink (Air/Ground)");
    const electricNodeIndex = NodeUtils.findNodeIndex("M.2.2 Energy Input");
    const minValue = 0.1;

    // Preserve the original heating demand unless explicitly changed
    HP = Math.max(minValue, requiredOutput);
    
    if (isGasHeating) {
      // For gas mode, maintain same heating output but adjust input based on efficiency
      M22D = Math.max(minValue, HP / StateManager.getValue('copHeating'));
      M22S = 0;
    } else {
      // Heat pump mode
      M22D = Math.max(minValue, HP / StateManager.getValue('copHeating'));
      M22S = Math.max(minValue, HP - M22D);
    }

    // Update all heat-related links
    const linkUpdates = [
      { source: sinkNodeIndex, target: heatpumpIndex, value: isGasHeating ? 0 : M22S },
      { source: electricNodeIndex, target: heatpumpIndex, value: M22D },
      { source: heatpumpIndex, target: buildingIndex, value: HP }
    ];

    linkUpdates.forEach(update => {
      LinkUtils.updateLink(update.source, update.target, update.value, true);
    });
  },

  updateHeatPumpRatio() {
    if (isGasHeating) return;

    // Recalculate M22D based on new COP
    M22D = Math.max(0.1, HP / StateManager.getValue('copHeating'));
    M22S = Math.max(0.1, HP - M22D);

    // Update the heat pump node links
    const heatpumpIndex = NodeUtils.findNodeIndex("Heating Demand");
    const sinkNodeIndex = NodeUtils.findNodeIndex("M.2.2 Sink (Air/Ground)");
    const electricNodeIndex = NodeUtils.findNodeIndex("M.2.2 Energy Input");

    LinkUtils.updateLink(sinkNodeIndex, heatpumpIndex, M22S, true);
    LinkUtils.updateLink(electricNodeIndex, heatpumpIndex, M22D, true);
  },

  updateMVHR(newEfficiency) {
    const v35Link = LinkUtils.findLink(
      NodeUtils.findNodeIndex("Building"),
      NodeUtils.findNodeIndex("V.3.5 Unrecovered Ventilation")
    );

    if (!v35Link) return;

    v35Link.originalValue = v35Link.originalValue || v35Link.value;
    const newValue = Math.max(0.1, v35Link.originalValue * (1 - newEfficiency));
    
    LinkUtils.updateLink(
      NodeUtils.findNodeIndex("Building"),
      NodeUtils.findNodeIndex("V.3.5 Unrecovered Ventilation"),
      newValue,
      true
    );

    this.updateBuildingBalance();
  },

  updateDWHR(newEfficiency) {
    const buildingIndex = NodeUtils.findNodeIndex("Building");
    const links = {
      demand: LinkUtils.findLink(
        NodeUtils.findNodeIndex("W.2.D.N SHW Net Demand"),
        buildingIndex
      ),
      waste: LinkUtils.findLink(
        buildingIndex,
        NodeUtils.findNodeIndex("W.2.W SHW Wasted")
      )
    };

    if (!links.demand || !links.waste) return;

    links.demand.originalValue = links.demand.originalValue || links.demand.value;
    const newValue = Math.max(0.1, links.demand.originalValue * (1 - newEfficiency));

    LinkUtils.updateLink(
      NodeUtils.findNodeIndex("W.2.D.N SHW Net Demand"),
      buildingIndex,
      newValue,
      true
    );
    LinkUtils.updateLink(
      buildingIndex,
      NodeUtils.findNodeIndex("W.2.W SHW Wasted"),
      newValue,
      true
    );
  },

  updateTEDI() {
    const tediIndex = NodeUtils.findNodeIndex("TEDI");
    const buildingIndex = NodeUtils.findNodeIndex("Building");

    const tediTotal = [
      "B.4 Roof", "B.5 Walls Ae", "B.6 Floor Exposed", "B.7 Doors",
      "B.8.1 Windows N", "B.8.2 Windows E", "B.8.3 Windows S", "B.8.4 Windows W",
      "B.10 Floor Slab", "B.13.2 TB Penalty", "B.19.5 Air Leakage"
    ].reduce((sum, component) => {
      return sum + LinkUtils.getLinkValue("TEDI", component);
    }, 0);

    LinkUtils.updateLink(buildingIndex, tediIndex, tediTotal, true);
    this.updateBuildingBalance();
  }
};
</script>
<!--
//====================================================================================
// PART 7: D3 SANKEY VISUALIZATION
//====================================================================================
-->
<script>
// D3 Sankey Diagram Manager
const SankeyDiagram = {
  svg: d3.select("#sankey"),
  tooltip: d3.select("#tooltip"),
  sankey: d3.sankey()
    .nodeWidth(20)
    .nodePadding(15)
    .extent([[1, 1], [1100 - 1, 600 - 1]]),

  initialize() {
    this.linkGroup = this.svg.append("g").attr("class", "links");
    this.nodeGroup = this.svg.append("g").attr("class", "nodes");
    this.labelGroup = this.svg.append("g").attr("class", "labels");
  },

  render(isInitialLoad = false) {
    if (!data.nodes || !data.links) {
      console.error("Invalid data structure:", data);
      updateStatus('Error: Invalid data structure', 'error');
      return;
    }

    if (showEmissions) {
      this.updateEmissionsFlows();
    }

    try {
      const { nodes, links } = this.sankey(data);
      nodes.forEach(node => {
        node.displayColor = d3.color(node.color).darker(0.3);
      });

      const maxX = d3.max(nodes, d => d.x0);
      this.renderLinks(links, isInitialLoad, maxX);
      this.renderNodes(nodes, isInitialLoad, maxX);
      this.renderLabels(nodes, isInitialLoad, maxX);
    } catch (error) {
      console.error("Error rendering chart:", error);
      updateStatus('Error rendering chart: ' + error.message, 'error');
    }
  },

  renderLinks(links, isInitialLoad, maxX) {
    const link = this.linkGroup.selectAll(".link")
      .data(links, d => {
        const source = NodeUtils.getSourceNodeIndex(d);
        const target = NodeUtils.getTargetNodeIndex(d);
        return `${source}-${target}`;
      });

    link.exit().remove();

    const linkEnter = link.enter()
      .append("path")
      .attr("class", "link")
      .on("mouseover", (event, d) => this.showLinkTooltip(event, d))
      .on("mouseout", () => this.hideTooltip());

    const linkUpdate = link.merge(linkEnter)
      .style("stroke", d => this.getLinkColor(d));

    if (isInitialLoad) {
      linkUpdate
        .attr("d", d3.sankeyLinkHorizontal())
        .transition()
        .duration(1000)
        .delay(d => (d.source.x0 / maxX) * 2000)
        .attr("stroke-width", d => Math.max(1, d.width));
    } else {
      linkUpdate
        .transition()
        .duration(1000)
        .attr("d", d3.sankeyLinkHorizontal())
        .attr("stroke-width", d => Math.max(1, d.width));
    }
  },

  renderNodes(nodes, isInitialLoad, maxX) {
    const node = this.nodeGroup.selectAll(".node")
      .data(nodes, d => d.name);

    node.exit().remove();

    const nodeEnter = node.enter()
      .append("rect")
      .attr("class", "node")
      .style("fill", d => d.displayColor)
      .style("fill-opacity", 1)
      .on("mouseover", (event, d) => this.showNodeTooltip(event, d))
      .on("mouseout", () => this.hideTooltip());

    const nodeUpdate = node.merge(nodeEnter);

    if (isInitialLoad) {
      nodeUpdate
        .attr("x", d => d.x0)
        .attr("y", d => d.y0)
        .attr("height", d => d.y1 - d.y0)
        .attr("width", 0)
        .transition()
        .duration(1000)
        .delay(d => (d.x0 / maxX) * 2000)
        .attr("width", d => d.x1 - d.x0);
    } else {
      nodeUpdate
        .transition()
        .duration(1000)
        .attr("x", d => d.x0)
        .attr("y", d => d.y0)
        .attr("height", d => d.y1 - d.y0)
        .attr("width", d => d.x1 - d.x0);
    }
  },

  renderLabels(nodes, isInitialLoad, maxX) {
    const label = this.labelGroup.selectAll(".node-label")
      .data(nodes, d => d.name);

    label.exit().remove();

    const labelEnter = label.enter()
      .append("text")
      .attr("class", "node-label")
      .style("opacity", 0);

    const labelUpdate = label.merge(labelEnter)
      .attr("x", d => (d.x0 < 1100 / 2 ? d.x1 + 5 : d.x0 - 5))
      .attr("y", d => (d.y0 + d.y1) / 2)
      .attr("text-anchor", d => (d.x0 < 1100 / 2 ? "start" : "end"))
      .text(d => this.formatNodeLabel(d));

    if (isInitialLoad) {
      labelUpdate
        .transition()
        .duration(1000)
        .delay(d => (d.x0 / maxX) * 2000)
        .style("opacity", 1);
    } else {
      labelUpdate
        .transition()
        .duration(1000)
        .style("opacity", 1);
    }
  },

  formatNodeLabel(node) {
    if (node.name.includes("Emissions")) {
      const totalEmissions = node.targetLinks?.reduce((sum, link) => sum + link.value, 0) || 0;
      const mtValue = (totalEmissions / 1000000).toFixed(1);
      return `${node.name} (${mtValue} MT)`;
    }
    return node.name;
  },

  showTooltip(content, event) {
    const padding = 10;
    this.tooltip
      .style("display", "block")
      .style("left", `${event.pageX + padding}px`)
      .style("top", `${event.pageY + padding}px`)
      .html(content);

    const tooltipRect = this.tooltip.node().getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    if (tooltipRect.right > viewportWidth) {
      this.tooltip.style("left", `${event.pageX - tooltipRect.width - padding}px`);
    }
    if (tooltipRect.bottom > viewportHeight) {
      this.tooltip.style("top", `${event.pageY - tooltipRect.height - padding}px`);
    }
  },

  hideTooltip() {
    this.tooltip.style("display", "none");
  },

  showNodeTooltip(event, d) {
    const content = this.createNodeTooltip(d);
    this.showTooltip(content, event);
    d3.select(event.target).style("fill-opacity", 0.8);
  },

  showLinkTooltip(event, d) {
    const content = this.createLinkTooltip(d);
    this.showTooltip(content, event);
    d3.select(event.target).style("stroke-opacity", 0.9);
  },

  createNodeTooltip(d) {
    const incoming = data.links.filter(l => NodeUtils.getTargetNodeIndex(l) === d.index);
    const outgoing = data.links.filter(l => NodeUtils.getSourceNodeIndex(l) === d.index);

    let html = `<div class="tooltip-title">${d.name}</div>`;

    if (d.name.includes("Emissions")) {
      const totalEmissions = d.targetLinks?.reduce((sum, link) => sum + link.value, 0) || 0;
      const scope = d.name.includes("1") ? "Direct emissions from gas combustion" : "Indirect emissions from electricity use";
      html += `
        <div class="tooltip-value">
          Total: ${(totalEmissions/1000000).toFixed(2)} MT CO2e
          <br><small>${scope}</small>
        </div>`;
    } else {
      html += `<div class="tooltip-value">Total Value: ${this.formatValue(d.value)}</div>`;
    }

    if (incoming.length > 0) html += this.buildFlowSection("Incoming", incoming, true);
    if (outgoing.length > 0) html += this.buildFlowSection("Outgoing", outgoing, false);

    return html;
  },

  createLinkTooltip(d) {
    return `
      <div class="tooltip-title">Flow Details</div>
      <div class="tooltip-flow"><span>From: ${d.source.name}</span></div>
      <div class="tooltip-flow"><span>To: ${d.target.name}</span></div>
      <div class="tooltip-flow"><span>Value: ${this.formatValue(d.value)}</span></div>
    `;
  },

  buildFlowSection(title, flows, isIncoming) {
    let html = `<div style="margin-top: 8px;"><strong>${title}:</strong></div>`;
    flows.forEach(flow => {
      const nodeName = isIncoming ? 
        data.nodes[NodeUtils.getSourceNodeIndex(flow)].name :
        data.nodes[NodeUtils.getTargetNodeIndex(flow)].name;
      html += `
        <div class="tooltip-flow">
          <span>${nodeName}</span>
          <span>${this.formatValue(flow.value)}</span>
        </div>`;
    });
    return html;
  },

  formatValue(value) {
    return `${value.toFixed(1)} kWh`;
  },

  getLinkColor(d) {
    if (d.source.name === "Building" || d.target.name === "Building") {
      return d.source.name === "Building" ? 
        d3.color(d.target.color).brighter(0.2) :
        d3.color(d.source.color);
    }
    return d3.interpolateRgb(d.source.color, d.target.color)(0.5);
  },

  updateEmissionsFlows() {
    const scope1NodeIndex = NodeUtils.findNodeIndex("E1 Scope 1 Emissions");
    const scope2NodeIndex = NodeUtils.findNodeIndex("E2 Scope 2 Emissions");

    // Remove existing emissions flows
    data.links = data.links.filter(link => {
      const targetIdx = NodeUtils.getTargetNodeIndex(link);
      return targetIdx !== scope1NodeIndex && targetIdx !== scope2NodeIndex;
    });

    if (showEmissions) {
      const gridIntensity = parseFloat(document.getElementById('gridIntensity').value) || 0;

      // Handle electrical loads (Scope 2)
      this.calculateElectricalEmissions(gridIntensity, scope2NodeIndex);

      // Handle heating and DHW
      this.calculateHeatingEmissions(gridIntensity, scope1NodeIndex, scope2NodeIndex);
    }
  },

  calculateElectricalEmissions(gridIntensity, scope2NodeIndex) {
    const electricalSources = ["G.3.1 Plug Light Equipment"];
    electricalSources.forEach(sourceName => {
      const nodeIndex = NodeUtils.findNodeIndex(sourceName);
      if (nodeIndex === -1) return;

      const flowValue = data.links.reduce((sum, link) => {
        if (NodeUtils.getSourceNodeIndex(link) === nodeIndex) {
          return sum + link.value;
        }
        return sum;
      }, 0);

      if (flowValue > 0.1) {
        const emissionsValue = flowValue * gridIntensity;
        if (emissionsValue > 0.1) {
          data.links.push({
            source: nodeIndex,
            target: scope2NodeIndex,
            value: emissionsValue
          });
        }
      }
    });
  },

  calculateHeatingEmissions(gridIntensity, scope1NodeIndex, scope2NodeIndex) {
    const heatingNodes = [
      { name: isGasHeating ? "Heating Demand" : "M.2.2 Energy Input" },
      { name: "W.2.D.N SHW Net Demand" }
    ];

    heatingNodes.forEach(({ name }) => {
      const nodeIndex = NodeUtils.findNodeIndex(name);
      if (nodeIndex === -1) return;

      const flowValue = data.links.reduce((sum, link) => {
        if (NodeUtils.getSourceNodeIndex(link) === nodeIndex) {
          return sum + link.value;
        }
        return sum;
      }, 0);

      if (flowValue > 0.1) {
        const emissionsValue = isGasHeating ?
          (flowValue / CONFIG.EMISSIONS.GAS_ENERGY_DENSITY) * CONFIG.EMISSIONS.GAS_INTENSITY :
          flowValue * gridIntensity;

        if (emissionsValue > 0.1) {
          data.links.push({
            source: nodeIndex,
            target: isGasHeating ? scope1NodeIndex : scope2NodeIndex,
            value: emissionsValue
          });
        }
      }
    });
  },

  resize() {
    const width = document.querySelector('.diagram-container').clientWidth;
    this.svg.attr("width", width);
    this.sankey.extent([[1, 1], [width - 1, 600 - 1]]);
    this.render(false);
  }
};
</script>

<script>
// Control Panel Manager
const ControlPanel = {
  initialize() {
    this.initializeControls();
    this.initializeEventListeners();
    this.updateValueDisplays();
    this.calculateTotalEnergyCost();
  },

  initializeControls() {
    if (!data?.nodes || !data?.links) {
      console.error("Invalid data structure");
      return;
    }

    const gainsBody = document.getElementById("gainsControlsBody");
    const lossesBody = document.getElementById("lossesControlsBody");
    gainsBody.innerHTML = "";
    lossesBody.innerHTML = "";

    const buildingIndex = NodeUtils.findNodeIndex("Building");
    const tediIndex = NodeUtils.findNodeIndex("TEDI");

    data.links.forEach(link => {
      const linkSource = NodeUtils.getSourceNodeIndex(link);
      const linkTarget = NodeUtils.getTargetNodeIndex(link);
      
      if (linkTarget === buildingIndex) {
        this.createControlRow(gainsBody, link, linkSource, linkTarget);
      }
      if (linkSource === buildingIndex || 
          (linkSource === tediIndex && data.nodes[linkTarget].name.startsWith("B."))) {
        this.createControlRow(lossesBody, link, linkSource, linkTarget);
      }
    });
  },

  createControlRow(tbody, link, sourceIndex, targetIndex) {
    const row = document.createElement("tr");
    
    // Name cell
    const nameCell = document.createElement("td");
    nameCell.textContent = `${data.nodes[sourceIndex].name} → ${data.nodes[targetIndex].name}`;
    nameCell.style.fontSize = "11px";

    // Value cell
    const valueCell = this.createValueCell(link, sourceIndex, targetIndex);

    // Control cell (slider or calculated indicator)
    const controlCell = DataManager.isCalculatedFlow(
      data.nodes[sourceIndex].name, 
      data.nodes[targetIndex].name
    ) ? this.createCalculatedCell() : this.createSliderCell(link, sourceIndex, targetIndex);

    row.append(nameCell, valueCell, controlCell);
    tbody.appendChild(row);
  },

  createValueCell(link, sourceIndex, targetIndex) {
    const cell = document.createElement("td");
    cell.style.width = "50px";

    const display = document.createElement("span");
    display.className = "value-display";
    display.setAttribute('data-source', data.nodes[sourceIndex].name);
    display.setAttribute('data-target', data.nodes[targetIndex].name);
    display.textContent = link.value.toFixed(1);

    cell.style.background = `linear-gradient(90deg, 
      ${data.nodes[sourceIndex].color}40 0%, 
      ${data.nodes[targetIndex].color}40 100%
    )`;
    cell.style.borderRadius = "3px";
    cell.style.padding = "4px 8px";
    cell.appendChild(display);

    return cell;
  },

  createSliderCell(link, sourceIndex, targetIndex) {
    const cell = document.createElement("td");
    cell.className = "slider-cell";

    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "0";
    slider.max = `${Math.max(link.value * 4, 300)}`;
    slider.step = "0.1";
    slider.value = link.value;

    slider.addEventListener("input", (e) => {
      LinkUtils.updateLink(sourceIndex, targetIndex, parseFloat(e.target.value));
      EnergyCalculator.updateBuildingBalance();
      this.updateValueDisplays();
      SankeyDiagram.render(false);
      this.calculateTotalEnergyCost();
    });

    cell.appendChild(slider);
    return cell;
  },

  createCalculatedCell() {
    const cell = document.createElement("td");
    cell.className = "slider-cell";

    const label = document.createElement("em");
    label.textContent = "Calculated";
    label.style.color = "#666";
    label.style.fontSize = "11px";
    label.style.marginLeft = "8px";

    cell.appendChild(label);
    return cell;
  },

  updateValueDisplays() {
    document.querySelectorAll('.value-display').forEach(display => {
      const sourceName = display.getAttribute('data-source');
      const targetName = display.getAttribute('data-target');
      
      let value = 0;
      if (sourceName === "M.2.2 Energy Input") {
        value = M22D;
      } else if (sourceName === "M.2.2 Sink (Air/Ground)") {
        value = M22S;
      } else if (sourceName === "Heating Demand") {
        value = HP;
      } else {
        const sourceIndex = NodeUtils.findNodeIndex(sourceName);
        const targetIndex = NodeUtils.findNodeIndex(targetName);
        const link = LinkUtils.findLink(sourceIndex, targetIndex);
        if (link) value = link.value;
      }
      display.textContent = value.toFixed(1);
    });
  },

  calculateTotalEnergyCost() {
    const energyCost = parseFloat(document.getElementById('energyCost').value) || 0;
    const gridIntensity = parseFloat(document.getElementById('gridIntensity').value) || 0;
    const valueDisplays = document.getElementsByClassName('value-display');

    let totalEnergy = 0;
    let gasEnergy = 0;
    let electricEnergy = 0;

    for (let display of valueDisplays) {
      const value = parseFloat(display.textContent);
      const sourceName = display.getAttribute('data-source');
      
      if (isGasHeating && (sourceName === "Heating Demand" || sourceName === "W.2.D.N SHW Net Demand")) {
        gasEnergy += value;
      } else if (sourceName !== "M.2.2 Sink (Air/Ground)") {
        electricEnergy += value;
      }
      totalEnergy += value;
    }

    totalEnergy -= M22S;
    const totalCost = totalEnergy * energyCost;
    
    document.getElementById('totalEnergyCost').textContent = totalCost.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });

    let totalEmissions = 0;
    totalEmissions += (electricEnergy * gridIntensity) / 1000000;

    if (isGasHeating) {
      const gasVolume = gasEnergy / CONFIG.EMISSIONS.GAS_ENERGY_DENSITY;
      totalEmissions += (gasVolume * CONFIG.EMISSIONS.GAS_INTENSITY) / 1000000;
    }

    document.getElementById('totalEmissions').textContent = totalEmissions.toFixed(2);
  },

  initializeEventListeners() {
    // File handling
    document.getElementById('importButton').addEventListener('click', () => {
      document.getElementById('csvFile').click();
    });

    document.getElementById('csvFile').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) await EventHandlers.handleFileImport(file);
    });

    document.getElementById('applyButton').addEventListener('click', 
      EventHandlers.handleApplyChanges
    );

    // Layout controls
    document.getElementById('toggleSpacingButton').addEventListener('click', function() {
      spacingCollapsed = !spacingCollapsed;
      SankeyDiagram.sankey.nodePadding(spacingCollapsed ? 0 : 15);
      this.textContent = spacingCollapsed ? "Show as Sankey Diagram" : "Show as Energy Balance";
      SankeyDiagram.render(false);
    });

    document.getElementById('widthMultiplier').addEventListener('input', (e) => {
      widthMultiplier = e.target.value / 100;
      document.getElementById('widthValue').textContent = `${e.target.value}%`;
      SankeyDiagram.sankey.nodeWidth(20 * widthMultiplier);
      SankeyDiagram.render(false);
    });

    // System controls
    document.getElementById('resetButton').addEventListener('click', 
      EventHandlers.handleReset
    );

    document.getElementById('toggleEmissionsButton').addEventListener('click', function() {
      showEmissions = !showEmissions;
      this.textContent = showEmissions ? 'Hide Emissions' : 'Show Emissions';
      SankeyDiagram.render(false);
    });

    document.getElementById('heatSourceButton').addEventListener('click', 
      EventHandlers.handleHeatSourceToggle
    );

    // Efficiency inputs
    const efficiencyInputs = [
      'energyCost', 'gridIntensity', 'copCooling', 'copHeating', 
      'mvhrEfficiency', 'dwhrEfficiency'
    ];
    
    efficiencyInputs.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', (e) => {
          EventHandlers.handleEfficiencyChange(e, id);
        });
      }
    });

    // Window resize handling
    window.addEventListener('resize', () => SankeyDiagram.resize());
  }
};

// Event Handlers
const EventHandlers = {
  handleEfficiencyChange(e, id) {
    const value = parseFloat(e.target.value);
    if (isNaN(value)) return;

    switch(id) {
      case 'copHeating':
        StateManager.setValue('copHeating', value);
        EnergyCalculator.updateHeatPumpRatio();
        EnergyCalculator.updateBuildingBalance();
        break;
      case 'copCooling':
        StateManager.setValue('copCooling', value);
        break;
      case 'mvhrEfficiency':
        StateManager.setValue('mvhrEfficiency', value);
        EnergyCalculator.updateMVHR(value);
        break;
      case 'dwhrEfficiency':
        StateManager.setValue('dwhrEfficiency', value);
        EnergyCalculator.updateDWHR(value);
        break;
      case 'energyCost':
      case 'gridIntensity':
        ControlPanel.calculateTotalEnergyCost();
        if (showEmissions) {
          SankeyDiagram.render(false);
        }
        break;
    }

    ControlPanel.updateValueDisplays();
  },

  async handleFileImport(file) {
    if (!file) return;

    document.getElementById('fileName').textContent = file.name;
    document.getElementById('applyButton').style.display = 'inline';

    try {
      pendingImportData = await FileHandler.handleImport(file);
      
      // Apply global updates immediately
      if (pendingImportData.globalUpdates) {
        StateManager.updateFromImport(pendingImportData.globalUpdates);
        
        // Trigger necessary updates
        EnergyCalculator.updateDWHR(StateManager.getValue('dwhrEfficiency'));
        EnergyCalculator.updateMVHR(StateManager.getValue('mvhrEfficiency'));
        EnergyCalculator.updateHeatPumpRatio();
      }

      updateStatus(`File loaded successfully. Click 'Apply Changes' to update flows.`, 'success');
    } catch (error) {
      console.error('Import error:', error);
      updateStatus('Error importing file: ' + error.message, 'error');
    }
  },

  handleApplyChanges() {
    if (!pendingImportData) {
      updateStatus('No changes to apply', 'error');
      return;
    }

    try {
      // Update data while preserving state
      const backup = DataManager.backup();
      
      data = pendingImportData;
      originalData = JSON.parse(JSON.stringify(pendingImportData));
      NodeUtils.ensureNodeReferences();

      document.getElementById('applyButton').style.display = 'none';
      pendingImportData = null;

      updateStatus(`Changes applied successfully`, 'success');
      ControlPanel.initializeControls();
      SankeyDiagram.render(true);
      ControlPanel.calculateTotalEnergyCost();
    } catch (error) {
      console.error('Error applying changes:', error);
      updateStatus('Error applying changes: ' + error.message, 'error');
    }
  },

  handleReset() {
    // Reset state management
    StateManager.reset();
    
    // Reset data to original state
    data = JSON.parse(JSON.stringify(originalData));
    NodeUtils.ensureNodeReferences();

    // Reset system variables
    HP = M22D = M22S = 0;

    updateStatus('Reset to original values', 'success');
    ControlPanel.initializeControls();
    SankeyDiagram.render(true);
    ControlPanel.calculateTotalEnergyCost();
  },

  handleHeatSourceToggle() {
    const button = document.getElementById('heatSourceButton');
    const copHeatingInput = document.getElementById('copHeating');
    const copHeatingLabel = document.getElementById('copHeatingLabel');

    // Store current values
    const currentHP = HP;
    const currentG7 = LinkUtils.getLinkValue(
      "Building", 
      "G.7 Unusable Heating Gains"
    );

    isGasHeating = !isGasHeating;
    
    // Update UI
    button.style.backgroundColor = isGasHeating ? '#BE343D' : '#A9D7F2';
    button.textContent = isGasHeating ? 'Gas Heat + SHW' : 'HP/Electric Heat+SHW';
    
    if (isGasHeating) {
      previousCOPh = StateManager.getValue('copHeating');
      StateManager.setValue('copHeating', 0.98);
      copHeatingInput.min = 0.5;
      copHeatingInput.max = 0.99;
      copHeatingInput.step = 0.01;
      copHeatingLabel.textContent = 'Heat+SHW Efficiency';
    } else {
      StateManager.setValue('copHeating', previousCOPh);
      copHeatingInput.min = 0.1;
      copHeatingInput.max = 20;
      copHeatingInput.step = 0.1;
      copHeatingLabel.textContent = 'COP Heating';
    }

    // Maintain heating demand
    HP = currentHP > 0 ? currentHP : HP;
    EnergyCalculator.updateHeatPumpValues(HP);
    
    // Restore unusable gains
    LinkUtils.updateLinkByNames(
      "Building", 
      "G.7 Unusable Heating Gains", 
      currentG7
    );

    // Update UI
    ControlPanel.updateValueDisplays();
    ControlPanel.calculateTotalEnergyCost();
    SankeyDiagram.render(false);
  }
};
</script>

<script>
function updateStatus(message, type = 'pending') {
  const statusElement = document.getElementById('statusMessage');
  statusElement.textContent = message;
  statusElement.className = `status-${type}`;
}

const Application = {
  async initialize() {
    try {
      // Initialize core components
      await this.initializeComponents();
      
      // Initialize state
      await this.initializeState();
      
      // Perform initial render
      await this.performInitialRender();
      
      // Report successful initialization
      const balance = EnergyCalculator.calculateEnergyBalance();
      updateStatus(
        balance.isBalanced ? 'Diagram ready - Energy balanced' : 'Diagram ready - Check energy balance',
        balance.isBalanced ? 'success' : 'warning'
      );
    } catch (error) {
      console.error("Application initialization failed:", error);
      updateStatus('Initialization error: ' + error.message, 'error');
    }
  },

  async initializeComponents() {
    try {
      // Initialize global state manager
      StateManager.initialize();
      
      // Initialize Sankey diagram
      SankeyDiagram.initialize();
      
      // Initialize control panel
      ControlPanel.initialize();

      return true;
    } catch (error) {
      console.error("Component initialization failed:", error);
      throw new Error(`Component initialization failed: ${error.message}`);
    }
  },

  async initializeState() {
    try {
      // Set initial system values from state manager
      COPh = StateManager.getValue('copHeating');
      COPc = StateManager.getValue('copCooling');
      MVHR = StateManager.getValue('mvhrEfficiency');
      DWHR = StateManager.getValue('dwhrEfficiency');

      // Ensure node references are properly set
      NodeUtils.ensureNodeReferences();
      
      // Initialize core calculations
      EnergyCalculator.updateDWHR(DWHR);
      EnergyCalculator.updateMVHR(MVHR);
      EnergyCalculator.updateBuildingBalance();

      return true;
    } catch (error) {
      console.error("State initialization failed:", error);
      throw new Error(`State initialization failed: ${error.message}`);
    }
  },

  async performInitialRender() {
    try {
      // Get container dimensions
      const container = document.querySelector('.diagram-container');
      const width = container.clientWidth;
      
      // Configure Sankey layout
      SankeyDiagram.svg.attr("width", width);
      SankeyDiagram.sankey.extent([[1, 1], [width - 1, 600 - 1]]);
      
      // Perform initial render
      SankeyDiagram.render(true);
      
      // Calculate initial energy cost
      ControlPanel.calculateTotalEnergyCost();

      return true;
    } catch (error) {
      console.error("Initial render failed:", error);
      throw new Error(`Initial render failed: ${error.message}`);
    }
  }
};

// Application startup
document.addEventListener('DOMContentLoaded', () => {
  Application.initialize().catch(error => {
    console.error("Application startup failed:", error);
    updateStatus('Application startup failed: ' + error.message, 'error');
  });
});
</script>
</body>
</html>
