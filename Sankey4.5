<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Energy Flow Sankey Diagram</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    /* Base Layout */
    body {
      font-family: Arial, sans-serif;
      margin: 0 auto;
      max-width: 1800px;
      padding: 20px;
      min-width: 400px;
    }

    /* Core Layout Components */
    .container { display: flex; gap: 10px; margin-top: 10px; flex-direction: column; }
    .button-row { display: flex; align-items: center; gap: 12px; padding: 10px 0; border-bottom: 1px solid #eee; }
    .status-row { min-height: 24px; padding: 4px 0; }
    .file-input-group { display: flex; align-items: center; gap: 8px; }
    .diagram-container { flex: 0 0 auto; width: 100%; }
    .controls-container {
      flex: 1 1 400px;
      min-width: 400px;
      background: #fff;
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    /* Sankey Elements */
    .node {
      stroke: #000;
      stroke-width: 1px;
      cursor: pointer;
    }
    .link {
      fill: none;
      stroke-opacity: 0.7;
      transition: stroke-opacity 0.2s;
      cursor: pointer;
    }
    .link:hover { stroke-opacity: 0.9; }
    .node-label {
      font-size: 11px;
      fill: black;
      pointer-events: none;
      font-weight: 500;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      padding: 12px;
      background: rgba(255, 255, 255, 0.98);
      border: 1px solid #ddd;
      border-radius: 6px;
      pointer-events: none;
      font-size: 12px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
      max-width: 300px;
      line-height: 1.4;
      z-index: 1000;
    }
    .tooltip-title {
      font-weight: 600;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    .tooltip-value { color: #666; font-size: 11px; }
    .tooltip-flow {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
    }

    /* Controls */
    .controls-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .controls-table th,
    .controls-table td {
      padding: 1px 8px;
      border: 1px solid #ddd;
      text-align: left;
    }
    .controls-table th:first-child { width: 210px; min-width: 210px; }
    .controls-table th:nth-child(2) { width: 50px; }
    .controls-table th {
      background-color: #f5f5f5;
      position: sticky;
      top: 0;
      z-index: 1;
      font-weight: 600;
    }

    /* UI Elements */
    .slider-cell { display: flex; align-items: center; gap: 5px; }
    input[type="range"] { width: 100px; accent-color: #666; }
    #widthMultiplier { height: 20px; margin: 0; }
    .value-display {
      min-width: 70px;
      text-align: right;
      font-size: 11px;
      font-weight: 500;
      color: #333;
    }

    /* Buttons */
    button {
      padding: 6px 12px;
      cursor: pointer;
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 12px;
      transition: all 0.2s;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button:hover {
      background-color: #e5e5e5;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Special Buttons */
    #importButton { background-color: #2196F3; color: white; border: none; }
    #importButton:hover { background-color: #1976D2; }
    #applyButton { background-color: #4CAF50; color: white; border: none; }
    #applyButton:hover { background-color: #45a049; }
    #applyButton:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
      transform: none;
    }

    /* Width Toggle */
    .width-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 3px 12px;
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      height: 23px;
    }
    .width-toggle label { font-size: 12px; color: #333; }

    /* Status Indicators */
    #fileName { color: #666; font-size: 12px; margin-left: 8px; }
    #statusMessage { font-size: 12px; padding: 4px 8px; border-radius: 4px; }
    .status-success { color: #4CAF50; background-color: #E8F5E9; }
    .status-error { color: #f44336; background-color: #FFEBEE; }
    .status-pending { color: #2196F3; background-color: #E3F2FD; }

    /* Layout Elements */
    h3, h4 { margin: 0; color: #333; }
    .tables-container { display: flex; gap: 20px; margin-top: 15px; }
    .table-section { flex: 1; min-width: 0; }

    /* Responsive */
    @media (max-width: 800px) {
      .tables-container { flex-direction: column; }
    }
  </style>
</head>
<body>
  <div class="button-row">
    <div class="file-input-group">
      <input type="file" id="csvFile" accept=".csv" style="display: none">
      <button id="importButton">Import</button>
      <span id="fileName"></span>
      <button id="applyButton" style="display: none;">Apply Changes</button>
    </div>
    <button id="toggleSpacingButton">Show as Energy Balance</button>
    <div class="width-toggle">
      <label for="widthMultiplier">Node Width:</label>
      <input type="range" id="widthMultiplier" min="100" max="800" value="100" step="10">
      <span id="widthValue">100%</span>
    </div>
    <button id="resetButton">Reset Values</button>
    <button id="toggleEmissionsButton" style="background-color: #808080; color: white;">Show Emissions</button>
    <button id="heatSourceButton" style="background-color: #A9D7F2; color: white;">HP/Electric Heat+SHW</button>
  </div>

  <div class="status-row">
    <span id="statusMessage"></span>
  </div>

  <div class="container">
    <div class="diagram-container">
      <svg id="sankey" height="600"></svg>
      <div id="tooltip" class="tooltip" style="display: none;"></div>
    </div>

    <div class="controls-container">
      <h4>Flow Control Panel</h4>
      
      <div class="cost-calculator" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e9ecef;">
        <div style="display: flex; flex-wrap: wrap; gap: 20px;">
          <!-- Energy Cost Section -->
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="energyCost" style="font-size: 12px;">Electricity $/kWh:</label>
            <input type="number" id="energyCost" min="0" step="0.01" value="0.12" 
                   style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            <span style="font-size: 12px;">
              <span style="font-weight: bold;">Total:</span> $<span id="totalEnergyCost">0.00</span>
            </span>
          </div>

          <!-- Grid Intensity Section -->
          <div style="display: flex; align-items: center; gap: 8px;">
            <label for="gridIntensity" style="font-size: 12px;">Grid Intensity (g/kWh):</label>
            <input type="number" id="gridIntensity" min="0" step="0.01" value="67.00" 
                   style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            <span style="font-size: 12px;">
              <span style="font-weight: bold;">Total:</span> <span id="totalEmissions">0.00</span> MTCO2e/yr
            </span>
          </div>

          <!-- Efficiency Settings -->
		  <div style="display: flex; flex-wrap: wrap; gap: 8px;">
		    <div style="display: flex; align-items: center; gap: 8px;">
		      <label for="copHeating" style="font-size: 12px;">
		        <span id="copHeatingLabel">COP Heating</span>:
		      </label>
		      <input type="number" id="copHeating" min="0.1" max="20" step="0.1" value="3.0" 
		             style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
		    </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="copCooling" style="font-size: 12px;">COP Cooling:</label>
              <input type="number" id="copCooling" min="0.1" max="20" step="0.1" value="2.0" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="mvhrEfficiency" style="font-size: 12px;">MVHR Efficiency:</label>
              <input type="number" id="mvhrEfficiency" min="0" max="1" step="0.01" value="0.80" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label for="dwhrEfficiency" style="font-size: 12px;">DWHR Efficiency:</label>
              <input type="number" id="dwhrEfficiency" min="0" max="0.75" step="0.01" value="0.50" 
                     style="width: 80px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
            </div>
          </div>
        </div>
      </div>

      <div class="tables-container">
        <div class="table-section">
          <table class="controls-table">
            <thead>
              <tr>
                <th>Energy Supplied</th>
                <th style="width: 50px;">Value</th>
                <th style="width: 120px;">Adjust</th>
              </tr>
            </thead>
            <tbody id="gainsControlsBody"></tbody>
          </table>
        </div>

        <div class="table-section">
          <table class="controls-table">
            <thead>
              <tr>
                <th>Energy Lost</th>
                <th style="width: 50px;">Value</th>
                <th style="width: 120px;">Adjust</th>
              </tr>
            </thead>
            <tbody id="lossesControlsBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  <script>
	  // Value State Management System - Add at the start of the script section
	  class ValueState {
	    constructor(defaultValue, min, max, formatter) {
	      this._default = defaultValue;
	      this._imported = null;
	      this._userEdited = null;
	      this._min = min;
	      this._max = max;
	      this._formatter = formatter || ((x) => x);
	    }

	    normalizeInput(value) {
	      if (typeof value === 'string') {
	        // Handle percentage strings
	        if (value.endsWith('%')) {
	          value = parseFloat(value) / 100;
	        } else {
	          value = parseFloat(value);
	        }
	      }
    
	      // Handle values > 1 that should be percentages
	      if (this._max <= 1 && value > 1) {
	        value = value / 100;
	      }

	      // Validate and constrain
	      value = Math.max(this._min, Math.min(this._max, value));
	      return this._formatter(value);
	    }

	    get value() {
	      return this._userEdited ?? this._imported ?? this._default;
	    }

	    setImported(value) {
	      this._imported = this.normalizeInput(value);
	      this._userEdited = null;  // Clear user edits when importing
	    }

	    setUserEdited(value) {
	      this._userEdited = this.normalizeInput(value);
	    }

	    reset() {
	      this._imported = null;
	      this._userEdited = null;
	    }
	  }

	  // Global Values Manager
	  const GlobalValues = {
	    copHeating: new ValueState(3.0, 0.1, 20, v => parseFloat(v.toFixed(1))),
	    copCooling: new ValueState(4.0, 0.1, 20, v => parseFloat(v.toFixed(1))),
	    mvhrEfficiency: new ValueState(0.80, 0, 1, v => parseFloat(v.toFixed(2))),
	    dwhrEfficiency: new ValueState(0.50, 0, 0.75, v => parseFloat(v.toFixed(2))),

	    updateUI() {
	      Object.entries(this).forEach(([key, state]) => {
	        if (state instanceof ValueState) {
	          const element = document.getElementById(key);
	          if (element) {
	            element.value = state.value;
	          }
	        }
	      });
	    }
	  };
	  
	  // Global Constants
	  const GAS_EMISSIONS_INTENSITY = 1921; // gCO2e/m3
	  const GAS_ENERGY_DENSITY = 10.36; // ekWh/m3

	  // Global State
	  let spacingCollapsed = false;
	  let widthMultiplier = 1;
	  let COPh = 3.0;
	  let previousCOPh = 3.0;
	  let COPc = 4.0;
	  let MVHR = 0.80;
	  let DWHR = 0.50;
	  let HP = 0;
	  let M22D = 0;
	  let M22S = 0;
	  let pendingImportData = null;
	  let showEmissions = false;
	  let isGasHeating = false;

      // Core Data Structure
  	let originalData = {
  		nodes: [
  		 { name: "Building", color: "#4A96BA" },                         // [0] Central node - all flows connect here
  		 { name: "G.1.1 Occupant Gains", color: "#FF8C00" },             // [1] Source: Internal gains from occupants
  		 { name: "G.3.1 Plug Light Equipment", color: "#A5D3ED" },       // [2] Source: Equipment & lighting gains
  		 { name: "W.2.D.N SHW Net Demand", color: "#BE343D" },           // [3] Source: Hot water demand (affected by DWHR)
  		 { name: "G.8.1 Windows N", color: "#F9DF4B" },                  // [4] Source: North solar gains
  		 { name: "G.8.2 Windows E", color: "#F9DF4B" },                  // [5] Source: East solar gains 
  		 { name: "G.8.3 Windows S", color: "#F9DF4B" },                  // [6] Source: South solar gains
  		 { name: "G.8.4 Windows W", color: "#F9DF4B" },                  // [7] Source: West solar gains
  		 { name: "M.2.2 Sink (Air/Ground)", color: "#D4B26F" },          // [8] Source: Heat pump source side (air/ground)
  		 { name: "M.2.2 Energy Input", color: "#A9D7F2" },       		 // [9] Source: Heat pump electrical input or Gas input in Gas mode
  		 { name: "Heating Demand", color: "#BFA586" },                   // [10] Node: Heating System Demand combines source + electric - or Gas
  		 { name: "B.4 Roof", color: "#8FAFA6" },                         // [11] Target: Roof heat loss
  		 { name: "B.5 Walls Ae", color: "#8FAFA6" },                     // [12] Target: Wall heat loss
  		 { name: "B.6 Floor Exposed", color: "#8FAFA6" },                // [13] Target: Exposed floor heat loss
  		 { name: "B.7 Doors", color: "#8FAFA6" },                        // [14] Target: Door heat loss
  		 { name: "B.8.1 Windows N", color: "#F9DF4B" },                  // [15] Target: North window heat loss
  		 { name: "B.8.2 Windows E", color: "#F9DF4B" },                  // [16] Target: East window heat loss
  		 { name: "B.8.3 Windows S", color: "#F9DF4B" },                  // [17] Target: South window heat loss
  		 { name: "B.8.4 Windows W", color: "#F9DF4B" },                  // [18] Target: West window heat loss
  		 { name: "B.10 Floor Slab", color: "#8FAFA6" },                  // [19] Target: Slab heat loss
  		 { name: "B.13.2 TB Penalty", color: "#8FAFA6" },                // [20] Target: Thermal bridge heat loss
  		 { name: "B.19.5 Air Leakage", color: "#A4D3ED" },               // [21] Target: Air infiltration heat loss
  		 { name: "V.3.5 Unrecovered Ventilation", color: "#A5D3ED" },    // [22] Target: Ventilation loss (affected by MVHR)
  		 { name: "W.2.W SHW Wasted", color: "#BE343D" },                 // [23] Target: Hot water waste (affected by DWHR)
  		 { name: "G.7 Unusable Heating Gains", color: "#FFA500" },       // [24] Target: Excess heat not needed
  		 { name: "TEDI", color: "#8FAFA6" },                             // [25] Target: Total envelope heat loss
		 { name: "E1 Scope 1 Emissions", color: "#808080" },             // [26] Target: Direct emissions from gas
		 { name: "E2 Scope 2 Emissions", color: "#808080" }              // [27] Target: Indirect emissions from electricity
		  ],

  		links: [
  		 { source: 1, target: 0, value: 12924.43 },                      // Occupant gains -> Building
  		 { source: 2, target: 0, value: 13970.88 },                      // Equipment gains -> Building
  		 { source: 3, target: 0, value: 3333.33 },                       // Hot water demand -> Building (reduced by DWHR)
  		 { source: 4, target: 0, value: 137.55 },                        // North solar -> Building
  		 { source: 5, target: 0, value: 4739.5 },                        // East solar -> Building
  		 { source: 6, target: 0, value: 7427.70 },                       // South solar -> Building
  		 { source: 7, target: 0, value: 1592.98 },                       // West solar -> Building
  		 { source: 8, target: 10, value: 28866.25 },                     // Source -> Heating Demand (M22S)
  		 { source: 9, target: 10, value: 10837.55 },                     // Electric -> Heating Demand (M22D)
  		 { source: 10, target: 0, value: 39703.79 },                     // Heat pump -> Building (HP)
  		 { source: 25, target: 11, value: 6152.64 },                     // TEDI -> Roof loss
  		 { source: 25, target: 12, value: 0.00 },                        // TEDI -> Wall loss
  		 { source: 25, target: 13, value: 0.00 },                        // TEDI -> Floor loss
  		 { source: 25, target: 14, value: 101.95 },                      // TEDI -> Door loss
  		 { source: 25, target: 15, value: 10704.96 },                    // TEDI -> North window loss
  		 { source: 25, target: 16, value: 6280.24 },                     // TEDI -> East window loss
  		 { source: 25, target: 17, value: 10704.96 },                    // TEDI -> South window loss
  		 { source: 25, target: 18, value: 6280.24 },                     // TEDI -> West window loss
  		 { source: 25, target: 19, value: 5037.96 },                     // TEDI -> Slab loss
  		 { source: 25, target: 20, value: 9032.2 },                      // TEDI -> Thermal bridge loss
  		 { source: 25, target: 21, value: 4718.21 },                     // TEDI -> Air leakage loss
  		 { source: 0, target: 22, value: 2570.04 },                      // Building -> Net Ventilation loss (reduced by MVHR)
  		 { source: 0, target: 23, value: 3333.33 },                      // Building -> Net Hot water waste (reduced by DWHR)
  		 { source: 0, target: 24, value: 19015.39 },                     // Building -> Unusable gains
  		 { source: 0, target: 25, value: 58911.41 }                      // Building -> TEDI (total envelope loss)
  		]
  	};

		let data = JSON.parse(JSON.stringify(originalData));
		
		// Excel Mapping Configuration for completion Dec 13th. 
		const ExcelMappingConfig = {
		  sheetName: "ENERGY BALANCE",
		  nodeValues: {
		    // Sources to Building
		    "G.1.1 Occupant Gains": "ENERGY BALANCE!D5",
		    "G.3.1 Plug Light Equipment": "ENERGY BALANCE!D6",
		    "W.2.D.N SHW Net Demand": "ENERGY BALANCE!D7",
		    "G.8.1 Windows N": "ENERGY BALANCE!D9",
		    "G.8.2 Windows E": "ENERGY BALANCE!D10",
		    "G.8.3 Windows S": "ENERGY BALANCE!D11",
		    "G.8.4 Windows W": "ENERGY BALANCE!D12",
		    "M.2.2 Sink (Air/Ground)": "ENERGY BALANCE!D17",
		    "M.2.2 Energy Input": "ENERGY BALANCE!D18",
		    "Heating Demand": "ENERGY BALANCE!D24",
		    // TEDI Losses
		    "B.4 Roof": "ENERGY BALANCE!F5",
		    "B.5 Walls Ae": "ENERGY BALANCE!F6",
		    "B.6 Floor Exposed": "ENERGY BALANCE!F7",
		    "B.7 Doors": "ENERGY BALANCE!F8",
		    "B.8.1 Windows N": "ENERGY BALANCE!F9",
		    "B.8.2 Windows E": "ENERGY BALANCE!F10",
		    "B.8.3 Windows S": "ENERGY BALANCE!F11",
		    "B.8.4 Windows W": "ENERGY BALANCE!F12",
		    "B.10 Floor Slab": "ENERGY BALANCE!F14",
		    "B.13.2 TB Penalty": "ENERGY BALANCE!F15",
		    "B.19.5 Air Leakage": "ENERGY BALANCE!F16",
		    "V.3.5 Unrecovered Ventilation": "ENERGY BALANCE!F17",
		    "W.2.W SHW Wasted": "ENERGY BALANCE!F18",
		    "G.7 Unusable Heating Gains": "ENERGY BALANCE!F19"
		  },
		  globalValues: {
		    "COPh": "REPORT!G118",
		    "COPc": "REPORT!I118",
		    "MVHR": "REPORT!D123",
		    "DWHR": "REPORT!D45",
		    "ProjectName": "REPORT!I14"
		  }
		};

		// Node Utilities
		const NodeUtils = {
		  findNodeIndex(name) {
		    return data.nodes.findIndex(node => node.name === name);
		  },

		  getNodeIndex(node) {
		    if (!node) return null;
		    return typeof node === 'number' ? node : 
		           typeof node === 'object' ? (node.index ?? data.nodes.indexOf(node)) : null;
		  },

		  getSourceNodeIndex(link) {
		    return link?.source ? (
		      typeof link.source === 'number' ? link.source :
		      typeof link.source === 'object' ? (link.source.index ?? data.nodes.indexOf(link.source)) : null
		    ) : null;
		  },

		  getTargetNodeIndex(link) {
		    return link?.target ? (
		      typeof link.target === 'number' ? link.target :
		      typeof link.target === 'object' ? (link.target.index ?? data.nodes.indexOf(link.target)) : null
		    ) : null;
		  },

		  ensureNodeReferences() {
		    data.links.forEach(link => {
		      if (typeof link.source === 'number') link.source = data.nodes[link.source];
		      if (typeof link.target === 'number') link.target = data.nodes[link.target];
		    });
		  }
		};

		// New FileHandler v4.5 for Excel and CSV support
		const FileHandler = {
		  async importFile(file) {
		    const extension = file.name.split('.').pop().toLowerCase();
		    try {
		      if (extension === 'xlsx') {
		        return await this._handleExcelImport(file);
		      } else if (extension === 'csv') {
		        return await this._handleCSVImport(file);
		      } else {
		        throw new Error('Unsupported file type. Please use .xlsx or .csv');
		      }
		    } catch (error) {
		      console.error('Import error:', error);
		      updateStatus('Error importing file: ' + error.message, 'error');
		      throw error;
		    }
		  },

		  async _handleExcelImport(file) {
		    return new Promise((resolve, reject) => {
		      const reader = new FileReader();
    
		      reader.onload = async (e) => {
		        try {
		          const data = new Uint8Array(e.target.result);
		          const workbook = XLSX.read(data, { type: 'array' });
        
		          // Handle global values exactly like CSV does
		          const globalUpdates = {};
		          const varMapping = {
		            'COPh': 'copHeating',
		            'COPc': 'copCooling',
		            'MVHR': 'mvhrEfficiency',
		            'DWHR': 'dwhrEfficiency'
		          };

		          // Process global values first, exactly as CSV does
		          Object.entries(ExcelMappingConfig.globalValues).forEach(([variable, cellRef]) => {
		            if (variable === 'ProjectName') return;
          
		            const [sheetName, cellAddr] = this._parseExcelReference(cellRef);
		            const sheet = workbook.Sheets[sheetName];
          
		            if (sheet && sheet[cellAddr]) {
		              let value = sheet[cellAddr].v;
            
		              // Handle Excel's number formats
		              if (sheet[cellAddr].t === 'n') {
		                if (value > 1 && value <= 100 && (variable === 'MVHR' || variable === 'DWHR')) {
		                  value = value / 100;
		                }
		              } else if (typeof value === 'string') {
		                if (value.endsWith('%')) {
		                  value = parseFloat(value) / 100;
		                } else {
		                  value = parseFloat(value);
		                }
		              }

		              const mappedVar = varMapping[variable];
		              if (mappedVar && GlobalValues[mappedVar] && !isNaN(value)) {
		                // Update GlobalValues state
		                GlobalValues[mappedVar].setImported(value);
		                globalUpdates[variable] = value;
              
		                // Update window globals immediately for compatibility
		                window[variable] = value;
		              }
		            }
		          });

		          // Important: Update UI immediately after processing globals
		          GlobalValues.updateUI();

		          // Trigger necessary updates in the correct order
		          if (globalUpdates.DWHR !== undefined) {
		            updateDWHR(GlobalValues.dwhrEfficiency.value);
		          }
		          if (globalUpdates.MVHR !== undefined) {
		            updateMVHR(GlobalValues.mvhrEfficiency.value);
		          }
		          if (globalUpdates.COPh !== undefined) {
		            COPh = GlobalValues.copHeating.value;
		            updateHeatPumpRatio();
		          }

		          const importedData = {
		            nodes: [...originalData.nodes],
		            links: [...originalData.links],
		            globalUpdates: globalUpdates,
		            projectName: this._extractProjectName(workbook) || "Unnamed Project"
		          };

		          updateStatus(`Loaded successfully: ${importedData.projectName}`, 'success');
		          resolve(importedData);
		        } catch (error) {
		          console.error('Excel processing error:', error);
		          reject(error);
		        }
		      };

		      reader.onerror = (error) => reject(error);
		      reader.readAsArrayBuffer(file);
		    });
		  },

		  async _handleCSVImport(file) {
		    return new Promise((resolve, reject) => {
		      const reader = new FileReader();
      
		      reader.onload = (event) => {
		        try {
		          const csv = event.target.result;
		          const sections = csv.split('##').map(s => s.trim());
          
		          const nodeLinks = sections.find(s => s.includes('Node and Link Alignment'));
		          if (!nodeLinks) throw new Error('Node and Link Alignment section not found');
          
		          const links = this._parseLinks(nodeLinks);
		          const globalUpdates = this._parseGlobals(sections);
		          const projectName = this._parseProjectInfo(sections);

		          const importedData = {
		            nodes: [...originalData.nodes],
		            links,
		            globalUpdates,
		            projectName
		          };

		          updateStatus(`Loaded successfully: ${projectName}`, 'success');
		          resolve(importedData);
		        } catch(error) {
		          console.error('Import error:', error);
		          updateStatus('Error importing CSV: ' + error.message, 'error');
		          reject(error);
		        }
		      };

		      reader.onerror = (error) => {
		        console.error('File reading error:', error);
		        updateStatus('Error reading file', 'error');
		        reject(error);
		      };

		      reader.readAsText(file);
		    });
		  },

		  _extractProjectName(workbook) {
		    if (ExcelMappingConfig.globalValues.ProjectName) {
		      const [sheetName, cellAddr] = this._parseExcelReference(ExcelMappingConfig.globalValues.ProjectName);
		      const sheet = workbook.Sheets[sheetName];
		      if (sheet && sheet[cellAddr]) {
		        return sheet[cellAddr].v.toString();
		      }
		    }
		    return null;
		  },

		  _normalizeValue(value, isPercentage = false) {
		    if (value === undefined || value === null) return null;

		    // Handle different Excel value types
		    if (typeof value === 'number') {
		      if (isPercentage && value > 1 && value <= 100) {
		        return value / 100;
		      }
		      return value;
		    }

		    if (typeof value === 'string') {
		      if (value.endsWith('%')) {
		        return parseFloat(value) / 100;
		      }
		      return parseFloat(value);
		    }

		    return null;
		  },

		  _parseExcelReference(ref) {
		    const [sheetName, cellAddr] = ref.split('!');
		    return [sheetName, cellAddr];
		  },

		  _parseLinks(nodeLinks) {
		    return nodeLinks.split('\n')
		      .filter(line => line.includes(',') && line.includes('[') && line.includes(']'))
		      .map(line => {
		        const parts = line.split(',');
		        const sourceMatch = parts[0].match(/\[(\d+)\]/);
		        const targetMatch = parts[1].match(/\[(\d+)\]/);
        
		        if (!sourceMatch || !targetMatch) return null;
        
		        return {
		          source: parseInt(sourceMatch[1]),
		          target: parseInt(targetMatch[1]),
		          value: parseFloat(parts[2])
		        };
		      })
		      .filter(link => link !== null);
		  },

		  _parseGlobals(sections) {
		    const globalsSection = sections.find(s => s.includes('Global Variables'));
		    const updates = {};

		    if (globalsSection) {
		      const varMapping = {
		        'COPh': 'copHeating',
		        'COPc': 'copCooling',
		        'MVHR': 'mvhrEfficiency',
		        'DWHR': 'dwhrEfficiency'
		      };

		      globalsSection.split('\n')
		        .filter(line => line.includes(',') && !line.includes('Variable,Value'))
		        .forEach(line => {
		          const [variable, value] = line.split(',').map(v => v.trim());
		          const mappedVar = varMapping[variable];
		          if (mappedVar && GlobalValues[mappedVar]) {
		            GlobalValues[mappedVar].setImported(value);
		            updates[variable] = GlobalValues[mappedVar].value;
		          }
		        });
		    }
		    return updates;
		  },

		  _parseProjectInfo(sections) {
		    const projectSection = sections.find(s => s.includes('Project Information'));
		    if (projectSection) {
		      const projectLine = projectSection.split('\n').find(line => line.includes('ProjectName'));
		      if (projectLine) return projectLine.split(',')[1].trim();
		    }
		    return "Unnamed Project";
		  }
		};

		//END SECTION 3 - CORE DATA AND UTILITIES      
		//START SECTION 4 - ENERGY CALCULATION ENGINE
		const EnergyCalculator = {
		 getLinkValue(sourceName, targetName) {
		   const sourceIdx = NodeUtils.findNodeIndex(sourceName);
		   const targetIdx = NodeUtils.findNodeIndex(targetName);
		   const link = data.links.find(l => {
		     const linkSource = NodeUtils.getSourceNodeIndex(l);
		     const linkTarget = NodeUtils.getTargetNodeIndex(l);
		     return linkSource === sourceIdx && linkTarget === targetIdx;
		   });
		   return link ? link.value : 0;
		 },

		 calculateEnergyBalance() {
		   // Calculate building inputs
		   const buildingInputs = {
		     G11: this.getLinkValue("G.1.1 Occupant Gains", "Building"),
		     G31: this.getLinkValue("G.3.1 Plug Light Equipment", "Building"), 
		     W2DN: this.getLinkValue("W.2.D.N SHW Net Demand", "Building"),
		     G81: this.getLinkValue("G.8.1 Windows N", "Building"),
		     G82: this.getLinkValue("G.8.2 Windows E", "Building"),
		     G83: this.getLinkValue("G.8.3 Windows S", "Building"),
		     G84: this.getLinkValue("G.8.4 Windows W", "Building")
		   };

		   // Calculate heat pump values
		   HP = this.getLinkValue("Heating Demand", "Building");
		   M22D = isGasHeating ? HP : HP / COPh;
		   M22S = isGasHeating ? 0 : HP - M22D;

		   // Sum total building energy
		   const BLDG = Object.values(buildingInputs).reduce((sum, val) => sum + val, 0) + HP;

		   // Calculate TEDI components
		   const tediComponents = {
		     B4: this.getLinkValue("TEDI", "B.4 Roof"),
		     B5: this.getLinkValue("TEDI", "B.5 Walls Ae"),
		     B6: this.getLinkValue("TEDI", "B.6 Floor Exposed"),
		     B7: this.getLinkValue("TEDI", "B.7 Doors"),
		     B81: this.getLinkValue("TEDI", "B.8.1 Windows N"),
		     B82: this.getLinkValue("TEDI", "B.8.2 Windows E"),
		     B83: this.getLinkValue("TEDI", "B.8.3 Windows S"),
		     B84: this.getLinkValue("TEDI", "B.8.4 Windows W"),
		     B10: this.getLinkValue("TEDI", "B.10 Floor Slab"),
		     B132: this.getLinkValue("TEDI", "B.13.2 TB Penalty"),
		     B195: this.getLinkValue("TEDI", "B.19.5 Air Leakage")
		   };

		   const TEDI = Object.values(tediComponents).reduce((sum, val) => sum + val, 0);

		   // Building losses
		   const V35 = this.getLinkValue("Building", "V.3.5 Unrecovered Ventilation");
		   const W2W = this.getLinkValue("Building", "W.2.W SHW Wasted");
		   const G7 = this.getLinkValue("Building", "G.7 Unusable Heating Gains");

		   const BLDG_LOSSES = TEDI + V35 + W2W + G7;

		   return {
		     BLDG,
		     TEDI,
		     BLDG_LOSSES,
		     isBalanced: Math.abs(BLDG - BLDG_LOSSES) < 0.1
		   };
		 }
		};

		// Energy Balance Functions
		function updateBuildingBalance() {
		 const buildingIndex = NodeUtils.findNodeIndex("Building");
		 const heatpumpIndex = NodeUtils.findNodeIndex("Heating Demand");

		 // Calculate total passive gains
		 const passiveGains = ["G.1.1 Occupant Gains", "G.3.1 Plug Light Equipment", 
		   "W.2.D.N SHW Net Demand", "G.8.1 Windows N", "G.8.2 Windows E", 
		   "G.8.3 Windows S", "G.8.4 Windows W"].reduce((sum, source) => {
		     const sourceIndex = NodeUtils.findNodeIndex(source);
		     const link = data.links.find(l => 
		       NodeUtils.getSourceNodeIndex(l) === sourceIndex && 
		       NodeUtils.getTargetNodeIndex(l) === buildingIndex
		     );
		     return sum + (link ? link.value : 0);
		   }, 0);

		 // Calculate total losses
		 const tediTotal = data.links.find(l =>
		   NodeUtils.getSourceNodeIndex(l) === buildingIndex &&
		   NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex("TEDI")
		 )?.value || 0;

		 const ventLoss = data.links.find(l =>
		   NodeUtils.getSourceNodeIndex(l) === buildingIndex &&
		   NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex("V.3.5 Unrecovered Ventilation")
		 )?.value || 0;

		 const dhwLoss = data.links.find(l =>
		   NodeUtils.getSourceNodeIndex(l) === buildingIndex &&
		   NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex("W.2.W SHW Wasted")
		 )?.value || 0;

		 const totalLosses = tediTotal + ventLoss + dhwLoss;

		 // Calculate required heating
		 const requiredHP = Math.max(0.1, totalLosses - passiveGains);
		 HP = requiredHP;

		 updateHeatPumpValues(requiredHP);

		 // Calculate unusable gains
		 const unusableGains = Math.max(0.1, passiveGains + requiredHP - totalLosses);
		 updateLinkSilent(buildingIndex, NodeUtils.findNodeIndex("G.7 Unusable Heating Gains"), unusableGains);

		 renderChart(false);
		}

		function updateTEDI() {
		 const tediIndex = NodeUtils.findNodeIndex("TEDI");
		 const buildingIndex = NodeUtils.findNodeIndex("Building");

		 const tediTotal = ["B.4 Roof", "B.5 Walls Ae", "B.6 Floor Exposed", "B.7 Doors",
		   "B.8.1 Windows N", "B.8.2 Windows E", "B.8.3 Windows S", "B.8.4 Windows W",
		   "B.10 Floor Slab", "B.13.2 TB Penalty", "B.19.5 Air Leakage"].reduce((sum, component) => {
		     const componentIndex = NodeUtils.findNodeIndex(component);
		     const link = data.links.find(l => 
		       NodeUtils.getSourceNodeIndex(l) === tediIndex && 
		       NodeUtils.getTargetNodeIndex(l) === componentIndex
		     );
		     return sum + (link ? link.value : 0);
		   }, 0);

		 const buildingToTediLink = data.links.find(l =>
		   NodeUtils.getSourceNodeIndex(l) === buildingIndex &&
		   NodeUtils.getTargetNodeIndex(l) === tediIndex
		 );
 
		 if (buildingToTediLink) {
		   buildingToTediLink.value = tediTotal;
		 }

		 updateBuildingBalance();
		}

		function updateMVHR(newEfficiency) {
		 const v35Link = data.links.find(l => 
		   NodeUtils.getSourceNodeIndex(l) === NodeUtils.findNodeIndex("Building") && 
		   NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex("V.3.5 Unrecovered Ventilation")
		 );

		 if (!v35Link) return;

		 v35Link.originalValue = v35Link.originalValue || v35Link.value;
		 const newValue = Math.max(0.1, v35Link.originalValue * (1 - newEfficiency));
		 updateLinkSilent(NodeUtils.findNodeIndex("Building"), 
		                  NodeUtils.findNodeIndex("V.3.5 Unrecovered Ventilation"), 
		                  newValue);

		 updateBuildingBalance(); // Add this line to trigger heating demand recalculation
		 renderChart(false);
		 calculateTotalEnergyCost();
		}

		function updateDWHR(newEfficiency) {
		 const buildingIndex = NodeUtils.findNodeIndex("Building");
		 const links = {
		   demand: data.links.find(l => 
		     NodeUtils.getSourceNodeIndex(l) === NodeUtils.findNodeIndex("W.2.D.N SHW Net Demand") && 
		     NodeUtils.getTargetNodeIndex(l) === buildingIndex
		   ),
		   waste: data.links.find(l => 
		     NodeUtils.getSourceNodeIndex(l) === buildingIndex && 
		     NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex("W.2.W SHW Wasted")
		   )
		 };

		 if (!links.demand || !links.waste) return;

		 links.demand.originalValue = links.demand.originalValue || links.demand.value;
		 const newValue = Math.max(0.1, links.demand.originalValue * (1 - newEfficiency));

		 updateLinkSilent(NodeUtils.findNodeIndex("W.2.D.N SHW Net Demand"), buildingIndex, newValue);
		 updateLinkSilent(buildingIndex, NodeUtils.findNodeIndex("W.2.W SHW Wasted"), newValue);

		 renderChart(false);
		 calculateTotalEnergyCost();
		}

		function updateHeatPumpValues(requiredOutput) {
		  const heatpumpIndex = NodeUtils.findNodeIndex("Heating Demand");
		  const buildingIndex = NodeUtils.findNodeIndex("Building");
		  const sinkNodeIndex = NodeUtils.findNodeIndex("M.2.2 Sink (Air/Ground)");
		  const electricNodeIndex = NodeUtils.findNodeIndex("M.2.2 Energy Input");
		  const minValue = 0.1;
  
		  // Preserve the original heating demand unless explicitly changed
		  HP = Math.max(minValue, requiredOutput);
		  if (isGasHeating) {
		    // For gas mode, maintain the same heating output
		    // but adjust the input based on efficiency
		    M22D = Math.max(minValue, HP / COPh);
		    M22S = 0;
		  } else {
		    // Heat pump mode
		    M22D = Math.max(minValue, HP / COPh);
		    M22S = Math.max(minValue, HP - M22D);
		  }
		  // Update all heat-related links
		  const linkUpdates = [
		    { source: sinkNodeIndex, target: heatpumpIndex, value: isGasHeating ? 0 : M22S },
		    { source: electricNodeIndex, target: heatpumpIndex, value: M22D },
		    { source: heatpumpIndex, target: buildingIndex, value: HP }
		  ];
		  linkUpdates.forEach(update => {
		    const linkIndex = findLinkIndex(update.source, update.target);
		    if (linkIndex !== -1) {
		      data.links[linkIndex].value = Number(update.value);
		    }
		  });
		  if (showEmissions) {
		    updateEmissionsFlows();
		  }
		  renderChart(false);
		  calculateTotalEnergyCost();
		}

		function updateDWHR(newEfficiency) {
		 const buildingIndex = NodeUtils.findNodeIndex("Building");
		 const links = {
		   demand: data.links.find(l => 
		     NodeUtils.getSourceNodeIndex(l) === NodeUtils.findNodeIndex("W.2.D.N SHW Net Demand") && 
		     NodeUtils.getTargetNodeIndex(l) === buildingIndex
		   ),
		   waste: data.links.find(l => 
		     NodeUtils.getSourceNodeIndex(l) === buildingIndex && 
		     NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex("W.2.W SHW Wasted")
		   )
		 };

		 if (!links.demand || !links.waste) return;

		 links.demand.originalValue = links.demand.originalValue || links.demand.value;
		 const newValue = Math.max(0.1, links.demand.originalValue * (1 - newEfficiency));

		 updateLinkSilent(NodeUtils.findNodeIndex("W.2.D.N SHW Net Demand"), buildingIndex, newValue);
		 updateLinkSilent(buildingIndex, NodeUtils.findNodeIndex("W.2.W SHW Wasted"), newValue);

		 renderChart(false);
		 calculateTotalEnergyCost();
		}
		
		function updateHeatPumpRatio() {
		  if (isGasHeating) return;
  
		  // Recalculate M22D based on new COP
		  M22D = Math.max(0.1, HP / COPh);
		  M22S = Math.max(0.1, HP - M22D);
  
		  // Update the heat pump node links
		  const heatpumpIndex = NodeUtils.findNodeIndex("Heating Demand");
		  const sinkNodeIndex = NodeUtils.findNodeIndex("M.2.2 Sink (Air/Ground)");
		  const electricNodeIndex = NodeUtils.findNodeIndex("M.2.2 Energy Input");
  
		  updateLinkSilent(sinkNodeIndex, heatpumpIndex, M22S);
		  updateLinkSilent(electricNodeIndex, heatpumpIndex, M22D);
  
		  updateValueDisplays();
		  updateSliders();
		  renderChart(false);
		  calculateTotalEnergyCost();
		}

		// Link Update Functions
		function updateLink(sourceIndex, targetIndex, newValue) {
		 const linkIndex = findLinkIndex(sourceIndex, targetIndex);
		 if (linkIndex === -1) return false;

		 const sourceName = data.nodes[sourceIndex].name;
		 const targetName = data.nodes[targetIndex].name;

		 data.links[linkIndex].value = Math.max(0.1, newValue);

		 const valueDisplay = document.querySelector(
		   `.value-display[data-source="${sourceName}"][data-target="${targetName}"]`
		 );
		 if (valueDisplay) {
		   valueDisplay.textContent = newValue.toFixed(1);
		 }

		 const tediIndex = NodeUtils.findNodeIndex("TEDI");
		 const buildingIndex = NodeUtils.findNodeIndex("Building");

		 if ([sourceIndex, targetIndex].includes(tediIndex)) {
		   updateTEDI();
		 }

		 if ([sourceIndex, targetIndex].includes(buildingIndex)) {
		   updateBuildingBalance();
		 }

		 renderChart(false);
		 calculateTotalEnergyCost();

		 return true;
		}

		function updateLinkSilent(sourceIndex, targetIndex, newValue) {
		 const linkIndex = findLinkIndex(sourceIndex, targetIndex);
		 if (linkIndex !== -1) {
		   data.links[linkIndex].value = Math.max(0.1, newValue);
		 }
		}

		function findLinkIndex(source, target) {
		 return data.links.findIndex(link => {
		   const linkSource = NodeUtils.getSourceNodeIndex(link);
		   const linkTarget = NodeUtils.getTargetNodeIndex(link);
		   return linkSource === source && linkTarget === target;
		 });
		}

		//END SECTION 4 - ENERGY CALCULATION ENGINE
	   //START SECTION 5 - D3 SANKEY VISUALIZATION

	   // D3 Sankey Setup
	   const sankey = d3.sankey()
	    .nodeWidth(20)
	    .nodePadding(15)
	    .extent([[1, 1], [1100 - 1, 600 - 1]]);

	   const svg = d3.select("#sankey");
	   const tooltip = d3.select("#tooltip");

	   const linkGroup = svg.append("g").attr("class", "links");
	   const nodeGroup = svg.append("g").attr("class", "nodes");
	   const labelGroup = svg.append("g").attr("class", "labels");

	   // Main Rendering Functions
	   function renderChart(isInitialLoad) {
	    if (!data.nodes || !data.links) {
	      console.error("Invalid data structure:", data);
	      updateStatus('Error: Invalid data structure', 'error');
	      return;
	    }

	    if (showEmissions) {
	      updateEmissionsFlows();
	    }

	    try {
	      const { nodes, links } = sankey(data);
	      nodes.forEach(node => {
	        node.displayColor = d3.color(node.color).darker(0.3);
	      });

	      const maxX = d3.max(nodes, d => d.x0);
	      renderLinks(links, isInitialLoad, maxX);
	      renderNodes(nodes, isInitialLoad, maxX);
	      renderLabels(nodes, isInitialLoad, maxX);
	    } catch (error) {
	      console.error("Error rendering chart:", error);
	      updateStatus('Error rendering chart: ' + error.message, 'error');
	    }
	   }

	   function renderLinks(links, isInitialLoad, maxX) {
	    const link = linkGroup.selectAll(".link")
	      .data(links, d => {
	        const source = NodeUtils.getSourceNodeIndex(d);
	        const target = NodeUtils.getTargetNodeIndex(d);
	        return `${source}-${target}`;
	      });

	    link.exit().remove();

	    const linkEnter = link.enter()
	      .append("path")
	      .attr("class", "link")
	      .on("mouseover", showLinkTooltip)
	      .on("mouseout", hideTooltip);

	    const linkUpdate = link.merge(linkEnter)
	      .style("stroke", getLinkColor);

	    if (isInitialLoad) {
	      linkUpdate
	        .attr("d", d3.sankeyLinkHorizontal())
	        .transition()
	        .duration(1000)
	        .delay(d => (d.source.x0 / maxX) * 2000)
	        .attr("stroke-width", d => Math.max(1, d.width));
	    } else {
	      linkUpdate
	        .transition()
	        .duration(1000)
	        .attr("d", d3.sankeyLinkHorizontal())
	        .attr("stroke-width", d => Math.max(1, d.width));
	    }
	   }

	   function renderNodes(nodes, isInitialLoad, maxX) {
	    const node = nodeGroup.selectAll(".node")
	      .data(nodes, d => d.name);

	    node.exit().remove();

	    const nodeEnter = node.enter()
	      .append("rect")
	      .attr("class", "node")
	      .style("fill", d => d.displayColor)
	      .style("fill-opacity", 1)
	      .on("mouseover", showNodeTooltip)
	      .on("mouseout", hideTooltip);

	    const nodeUpdate = node.merge(nodeEnter);

	    if (isInitialLoad) {
	      nodeUpdate
	        .attr("x", d => d.x0)
	        .attr("y", d => d.y0)
	        .attr("height", d => d.y1 - d.y0)
	        .attr("width", 0)
	        .transition()
	        .duration(1000)
	        .delay(d => (d.x0 / maxX) * 2000)
	        .attr("width", d => d.x1 - d.x0);
	    } else {
	      nodeUpdate
	        .transition()
	        .duration(1000)
	        .attr("x", d => d.x0)
	        .attr("y", d => d.y0)
	        .attr("height", d => d.y1 - d.y0)
	        .attr("width", d => d.x1 - d.x0);
	    }
	   }

	   function renderLabels(nodes, isInitialLoad, maxX) {
	    const label = labelGroup.selectAll(".node-label")
	      .data(nodes, d => d.name);

	    label.exit().remove();

	    const labelEnter = label.enter()
	      .append("text")
	      .attr("class", "node-label")
	      .style("opacity", 0);

	    const labelUpdate = label.merge(labelEnter)
	      .attr("x", d => (d.x0 < 1100 / 2 ? d.x1 + 5 : d.x0 - 5))
	      .attr("y", d => (d.y0 + d.y1) / 2)
	      .attr("text-anchor", d => (d.x0 < 1100 / 2 ? "start" : "end"))
	      .text(d => {
	        if (d.name.includes("Emissions")) {
	          const totalEmissions = d.targetLinks?.reduce((sum, link) => sum + link.value, 0) || 0;
	          const mtValue = (totalEmissions / 1000000).toFixed(1);
	          return `${d.name} (${mtValue} MT)`;
	        }
	        return d.name;
	      });

	    if (isInitialLoad) {
	      labelUpdate
	        .transition()
	        .duration(1000)
	        .delay(d => (d.x0 / maxX) * 2000)
	        .style("opacity", 1);
	    } else {
	      labelUpdate
	        .transition()
	        .duration(1000)
	        .style("opacity", 1);
	    }
	   }

	   // Tooltip Functions
	   function formatValue(value) {
	    return `${value.toFixed(1)} kWh`;
	   }

	   function showTooltip(content, event) {
	    const padding = 10;
	    tooltip
	      .style("display", "block")
	      .style("left", `${event.pageX + padding}px`)
	      .style("top", `${event.pageY + padding}px`)
	      .html(content);

	    const tooltipRect = tooltip.node().getBoundingClientRect();
	    const viewportWidth = window.innerWidth;
	    const viewportHeight = window.innerHeight;

	    if (tooltipRect.right > viewportWidth) {
	      tooltip.style("left", `${event.pageX - tooltipRect.width - padding}px`);
	    }
	    if (tooltipRect.bottom > viewportHeight) {
	      tooltip.style("top", `${event.pageY - tooltipRect.height - padding}px`);
	    }
	   }

	   function hideTooltip() {
	    tooltip.style("display", "none");
	   }

	   function showNodeTooltip(event, d) {
	    const content = createNodeTooltip(d);
	    showTooltip(content, event);
	    d3.select(event.target).style("fill-opacity", 0.8);
	   }

	   function showLinkTooltip(event, d) {
	    const content = createLinkTooltip(d);
	    showTooltip(content, event);
	    d3.select(event.target).style("stroke-opacity", 0.9);
	   }

	   function createNodeTooltip(d) {
	     const incoming = data.links.filter(l => NodeUtils.getTargetNodeIndex(l) === d.index);
	     const outgoing = data.links.filter(l => NodeUtils.getSourceNodeIndex(l) === d.index);

	     let html = `<div class="tooltip-title">${d.name}</div>`;
  
	     if (d.name.includes("Emissions")) {
	       const totalEmissions = d.targetLinks?.reduce((sum, link) => sum + link.value, 0) || 0;
	       const scope = d.name.includes("1") ? "Direct emissions from gas combustion" : "Indirect emissions from electricity use";
	       html += `
	         <div class="tooltip-value">
	           Total: ${(totalEmissions/1000000).toFixed(2)} MT CO2e
	           <br><small>${scope}</small>
	         </div>`;
	     } else {
	       html += `<div class="tooltip-value">Total Value: ${formatValue(d.value)}</div>`;
	     }

	     if (incoming.length > 0) html += buildFlowSection("Incoming", incoming, true);
	     if (outgoing.length > 0) html += buildFlowSection("Outgoing", outgoing, false);

	     return html;
	   }

	   function createLinkTooltip(d) {
	    return `
	      <div class="tooltip-title">Flow Details</div>
	      <div class="tooltip-flow"><span>From: ${d.source.name}</span></div>
	      <div class="tooltip-flow"><span>To: ${d.target.name}</span></div>
	      <div class="tooltip-flow"><span>Value: ${formatValue(d.value)}</span></div>
	    `;
	   }

	   function buildFlowSection(title, flows, isIncoming) {
	    let html = `<div style="margin-top: 8px;"><strong>${title}:</strong></div>`;
	    flows.forEach(flow => {
	      const nodeName = isIncoming ? 
	        data.nodes[NodeUtils.getSourceNodeIndex(flow)].name :
	        data.nodes[NodeUtils.getTargetNodeIndex(flow)].name;
	      html += `
	        <div class="tooltip-flow">
	          <span>${nodeName}</span>
	          <span>${formatValue(flow.value)}</span>
	        </div>`;
	    });
	    return html;
	   }

	   function getLinkColor(d) {
	    if (d.source.name === "Building" || d.target.name === "Building") {
	      return d.source.name === "Building" ? 
	        d3.color(d.target.color).brighter(0.2) :
	        d3.color(d.source.color);
	    }
	    return d3.interpolateRgb(d.source.color, d.target.color)(0.5);
	   }

	   //END SECTION 5 - D3 SANKEY VISUALIZATION
	   //START SECTION 6 - EVENT HANDLERS AND CONTROL PANEL

	   // Control Panel Functions
	   function calculateTotalEnergyCost() {
	    const energyCost = parseFloat(document.getElementById('energyCost').value) || 0;
	    const gridIntensity = parseFloat(document.getElementById('gridIntensity').value) || 0;
	    const valueDisplays = document.getElementsByClassName('value-display');

	    let totalEnergy = 0;
	    let gasEnergy = 0;
	    let electricEnergy = 0;

	    for (let display of valueDisplays) {
	      const value = parseFloat(display.textContent);
	      const sourceName = display.getAttribute('data-source');
   
	      if (isGasHeating && (sourceName === "Heating Demand" || sourceName === "W.2.D.N SHW Net Demand")) {
	        gasEnergy += value;
	      } else if (sourceName !== "M.2.2 Sink (Air/Ground)") {
	        electricEnergy += value;
	      }
	      totalEnergy += value;
	    }

	    totalEnergy -= M22S;
	    const totalCost = totalEnergy * energyCost;
	    document.getElementById('totalEnergyCost').textContent = totalCost.toLocaleString('en-US', {
	      minimumFractionDigits: 2,
	      maximumFractionDigits: 2
	    });

	    let totalEmissions = 0;
	    totalEmissions += (electricEnergy * gridIntensity) / 1000000;
 
	    if (isGasHeating) {
	      const gasVolume = gasEnergy / GAS_ENERGY_DENSITY;
	      totalEmissions += (gasVolume * GAS_EMISSIONS_INTENSITY) / 1000000;
	    }

	    document.getElementById('totalEmissions').textContent = totalEmissions.toFixed(2);
	   }

	   function updateValueDisplays() {
	    document.querySelectorAll('.value-display').forEach(display => {
	      const sourceName = display.getAttribute('data-source');
	      const targetName = display.getAttribute('data-target');
   
	      let value = 0;
	      if (sourceName === "M.2.2 Energy Input") {
	        value = M22D;
	      } else if (sourceName === "M.2.2 Sink (Air/Ground)") {
	        value = M22S;
	      } else if (sourceName === "Heatpump") {
	        value = HP;
	      } else {
	        const sourceIndex = NodeUtils.findNodeIndex(sourceName);
	        const targetIndex = NodeUtils.findNodeIndex(targetName);
	        const link = data.links.find(l => 
	          NodeUtils.getSourceNodeIndex(l) === sourceIndex && 
	          NodeUtils.getTargetNodeIndex(l) === targetIndex
	        );
	        if (link) value = link.value;
	      }
	      display.textContent = value.toFixed(1);
	    });
	   }

	   function updateSliders() {
	    document.querySelectorAll('input[type="range"]').forEach(slider => {
	      const row = slider.closest('tr');
	      if (!row) return;

	      const valueDisplay = row.querySelector('.value-display');
	      if (!valueDisplay) return;

	      const sourceName = valueDisplay.getAttribute('data-source');
	      const targetName = valueDisplay.getAttribute('data-target');
	      const link = data.links.find(l => 
	        NodeUtils.getSourceNodeIndex(l) === NodeUtils.findNodeIndex(sourceName) && 
	        NodeUtils.getTargetNodeIndex(l) === NodeUtils.findNodeIndex(targetName)
	      );

	      if (link) slider.value = link.value;
	    });
	   }

	   // Initialize Controls
	   function initializeControls() {
	    if (!data?.nodes || !data?.links) {
	      console.error("Invalid data structure");
	      return;
	    }

	    const gainsBody = document.getElementById("gainsControlsBody");
	    const lossesBody = document.getElementById("lossesControlsBody");
	    gainsBody.innerHTML = "";
	    lossesBody.innerHTML = "";

	    const buildingIndex = NodeUtils.findNodeIndex("Building");
	    const tediIndex = NodeUtils.findNodeIndex("TEDI");

	    data.links.forEach(link => {
	      const linkSource = NodeUtils.getSourceNodeIndex(link);
	      const linkTarget = NodeUtils.getTargetNodeIndex(link);
   
	      if (linkTarget === buildingIndex) {
	        createControlRow(gainsBody, link, linkSource, linkTarget);
	      }
	      if (linkSource === buildingIndex || 
	          (linkSource === tediIndex && data.nodes[linkTarget].name.startsWith("B."))) {
	        createControlRow(lossesBody, link, linkSource, linkTarget);
	      }
	    });
	   }

	   function createControlRow(tbody, link, sourceIndex, targetIndex) {
	     const row = document.createElement("tr");
  
	     // Create name cell
	     const nameCell = document.createElement("td");
	     nameCell.textContent = `${data.nodes[sourceIndex].name}  ${data.nodes[targetIndex].name}`;
	     nameCell.style.fontSize = "11px";

	     // Create value cell (using existing function)
	     const valueCell = createValueCell(link, sourceIndex, targetIndex);

	     // Create slider or calculated cell based on the flow type
	     let controlCell;
	     if (isCalculatedFlow(data.nodes[sourceIndex].name, data.nodes[targetIndex].name)) {
	       controlCell = createCalculatedCell();
	     } else {
	       controlCell = createSliderCell(link, sourceIndex, targetIndex);
	     }

	     row.append(nameCell, valueCell, controlCell);
	     tbody.appendChild(row);
	   }

	   function createValueCell(link, sourceIndex, targetIndex) {
	     const cell = document.createElement("td");
	     cell.style.width = "50px";
 
	     const display = document.createElement("span");
	     display.className = "value-display";
	     display.setAttribute('data-source', data.nodes[sourceIndex].name);
	     display.setAttribute('data-target', data.nodes[targetIndex].name);
	     display.textContent = link.value.toFixed(1);

	     cell.style.background = `linear-gradient(90deg, 
	       ${data.nodes[sourceIndex].color}40 0%, 
	       ${data.nodes[targetIndex].color}40 100%
	     )`;
	     cell.style.borderRadius = "3px";
	     cell.style.padding = "4px 8px";
	     cell.appendChild(display);

	     return cell;
	   }

	   function createSliderCell(link, sourceIndex, targetIndex) {
	     const cell = document.createElement("td");
	     cell.className = "slider-cell";
 
	     const slider = document.createElement("input");
	     slider.type = "range";
	     slider.min = "0";
	     slider.max = `${Math.max(link.value * 4, 300)}`;
	     slider.step = "0.1";
	     slider.value = link.value;

	     slider.addEventListener("input", (e) => {
	       updateLink(sourceIndex, targetIndex, parseFloat(e.target.value));
	       updateValueDisplays();
	       renderChart(false);
	       calculateTotalEnergyCost();
	     });

	     cell.appendChild(slider);
	     return cell;
	   }

	   function isCalculatedFlow(sourceName, targetName) {
	     // Define which flows are calculated
	     const calculatedFlows = [
	       { source: "Heating Demand", target: "Building" },
	       { source: "Building", target: "G.7 Unusable Heating Gains" },
	       { source: "Building", target: "TEDI" }
	     ];

	     return calculatedFlows.some(flow => 
	       flow.source === sourceName && flow.target === targetName
	     );
	   }

	   function createCalculatedCell() {
	     const cell = document.createElement("td");
	     cell.className = "slider-cell";
  
	     const label = document.createElement("em");
	     label.textContent = "Calculated";
	     label.style.color = "#666";
	     label.style.fontSize = "11px";
	     label.style.marginLeft = "8px";
  
	     cell.appendChild(label);
	     return cell;
	   }

	   // Event Handlers
	   const EventHandlers = {
	     handleEfficiencyChange(e, variable) {
	       const state = GlobalValues[variable.toLowerCase()];
	       if (state) {
	         state.setUserEdited(e.target.value);
	         window[variable] = state.value; // Keep window global in sync for compatibility
      
	         // Trigger appropriate updates based on which value changed
	         switch(variable) {
	           case 'MVHR':
	             updateMVHR(state.value);
	             break;
	           case 'DWHR':
	             updateDWHR(state.value);
	             break;
	           default:
	             updateBuildingBalance();
	         }
	       }
	     },

	     handleCOPChange(e) {
	       const state = GlobalValues.copHeating;
	       state.setUserEdited(e.target.value);
	       COPh = state.value;
	       updateHeatPumpRatio();
	     },

	     async handleFileImport(file) {
	       if (!file) return;
    
	       document.getElementById('fileName').textContent = file.name;
	       document.getElementById('applyButton').style.display = 'inline';

	       try {
	         pendingImportData = await FileHandler.importCSV(file);
      
	         // Apply global updates immediately and update UI
	         if (pendingImportData.globalUpdates) {
	           // Update window globals for compatibility
	           Object.entries(pendingImportData.globalUpdates).forEach(([variable, value]) => {
	             window[variable] = value;
	           });
        
	           // Update UI with new values
	           GlobalValues.updateUI();
        
	           // Trigger necessary updates in the correct order
	           if (pendingImportData.globalUpdates.DWHR !== undefined) {
	             updateDWHR(GlobalValues.dwhrEfficiency.value);
	           }
	           if (pendingImportData.globalUpdates.MVHR !== undefined) {
	             updateMVHR(GlobalValues.mvhrEfficiency.value);
	           }
	           if (pendingImportData.globalUpdates.COPh !== undefined) {
	             updateHeatPumpRatio();
	           }
	         }
      
	         updateStatus(`File loaded successfully. Click 'Apply Changes' to update flows.`, 'success');
	       } catch (error) {
	         console.error('Import error:', error);
	         updateStatus('Error importing CSV: ' + error.message, 'error');
	       }
	     },

	     handleApplyChanges() {
	       if (!pendingImportData) {
	         updateStatus('No changes to apply', 'error');
	         return;
	       }
    
	       try {
	         // Preserve the current global values state
	         const currentGlobals = {
	           COPh: GlobalValues.copHeating.value,
	           COPc: GlobalValues.copCooling.value,
	           MVHR: GlobalValues.mvhrEfficiency.value,
	           DWHR: GlobalValues.dwhrEfficiency.value
	         };

	         // Update data and references
	         data = pendingImportData;
	         originalData = JSON.parse(JSON.stringify(pendingImportData));
	         NodeUtils.ensureNodeReferences();
      
	         // Restore global values that were preserved
	         Object.entries(currentGlobals).forEach(([variable, value]) => {
	           window[variable] = value;
	         });
      
	         // Clean up and update UI
	         document.getElementById('applyButton').style.display = 'none';
	         pendingImportData = null;
      
	         updateStatus(`Changes applied successfully`, 'success');
	         initializeControls();
	         renderChart(true);
	         calculateTotalEnergyCost();
	       } catch (error) {
	         console.error('Error applying changes:', error);
	         updateStatus('Error applying changes: ' + error.message, 'error');
	       }
	     },

		 handleReset() {
		   // Reset global values to imported state (not defaults)
		   Object.values(GlobalValues).forEach(state => {
		     if (state instanceof ValueState) {
		       // Clear only user edits, keeping imported values if they exist
		       state._userEdited = null;
		     }
		   });

		   // Update UI with imported/default values
		   GlobalValues.updateUI();

		   // Reset data to originally imported state
		   data = JSON.parse(JSON.stringify(pendingImportData || originalData));
		   NodeUtils.ensureNodeReferences();

		   // Reset window globals to imported values
		   COPh = GlobalValues.copHeating.value;
		   COPc = GlobalValues.copCooling.value;
		   MVHR = GlobalValues.mvhrEfficiency.value;
		   DWHR = GlobalValues.dwhrEfficiency.value;

		   HP = M22D = M22S = 0;

		   updateStatus('Reset to imported values', 'success');
		   initializeControls();
		   renderChart(true);
		   calculateTotalEnergyCost();
		 }
	 };

	   //END SECTION 6 - EVENT HANDLERS AND CONTROL PANEL
	   //START SECTION 7 - INITIALIZATION AND ENTRY POINT

	   // Event Bindings Configuration
	   const eventBindings = [
	    // Cost and efficiency inputs
	    { id: 'energyCost', event: 'input', handler: calculateTotalEnergyCost },
	    { id: 'gridIntensity', event: 'input', handler: e => {
	      calculateTotalEnergyCost();
	      if (showEmissions) {
	        updateEmissionsFlows();
	        renderChart(false);
	      }
	    }},
 
	    // COP and efficiency handlers
	    { id: 'copCooling', event: 'input', handler: e => { COPc = parseFloat(e.target.value) || 4.0; }},
	    { id: 'copHeating', event: 'input', handler: e => {
	      COPh = parseFloat(e.target.value) || 3.0;
	      updateHeatPumpRatio();
	      updateBuildingBalance();
	    }},
	    { id: 'mvhrEfficiency', event: 'input', handler: e => {
	      MVHR = Math.max(0, Math.min(1, parseFloat(e.target.value) || 0));
	      updateMVHR(MVHR);
	      updateValueDisplays();
	      updateSliders();
	      calculateTotalEnergyCost();
	    }},
	    { id: 'dwhrEfficiency', event: 'input', handler: e => {
	      DWHR = Math.max(0, Math.min(1, parseFloat(e.target.value) || 0));
	      updateDWHR(DWHR);
	      updateValueDisplays();
	      updateSliders();
	      calculateTotalEnergyCost();
	    }},

	    // File handling
		{ id: 'importButton', event: 'click', handler: () => {
		  const fileInput = document.getElementById('csvFile');
		  fileInput.accept = '.csv,.xlsx';
		  fileInput.click();
		}},
		{ id: 'csvFile', event: 'change', handler: async (e) => {
		  const file = e.target.files[0];
		  if (file) {
		    try {
		      pendingImportData = await FileHandler.importFile(file);
		      document.getElementById('fileName').textContent = file.name;
		      document.getElementById('applyButton').style.display = 'inline';
		    } catch (error) {
		      console.error('Import error:', error);
		    }
		  }
		}},
	    { id: 'applyButton', event: 'click', handler: EventHandlers.handleApplyChanges },

	    // Layout controls
	    { id: 'toggleSpacingButton', event: 'click', handler: function() {
	      spacingCollapsed = !spacingCollapsed;
	      sankey.nodePadding(spacingCollapsed ? 0 : 15);
	      this.textContent = spacingCollapsed ? "Show as Sankey Diagram" : "Show as Energy Balance";
	      renderChart(false);
	    }},
	    { id: 'widthMultiplier', event: 'input', handler: e => {
	      widthMultiplier = e.target.value / 100;
	      document.getElementById('widthValue').textContent = `${e.target.value}%`;
	      sankey.nodeWidth(20 * widthMultiplier);
	      renderChart(false);
	    }},
	    { id: 'resetButton', event: 'click', handler: EventHandlers.handleReset },

	    // Emissions and Heat Source controls
	    { id: 'toggleEmissionsButton', event: 'click', handler: function() {
	      showEmissions = !showEmissions;
	      this.textContent = showEmissions ? 'Hide Emissions' : 'Show Emissions';
	      updateEmissionsFlows();
	      renderChart(false);
	    }},
		{
		  id: 'heatSourceButton', 
		  event: 'click', 
		  handler: function() {
		    // Store current state
		    const buildingIndex = NodeUtils.findNodeIndex("Building");
		    const heatpumpIndex = NodeUtils.findNodeIndex("Heating Demand");
		    const g7Index = NodeUtils.findNodeIndex("G.7 Unusable Heating Gains");
    
		    // Get current values BEFORE any changes
		    const currentHP = data.links.find(l => 
		      NodeUtils.getSourceNodeIndex(l) === heatpumpIndex && 
		      NodeUtils.getTargetNodeIndex(l) === buildingIndex
		    )?.value || 0;
    
		    const currentG7 = data.links.find(l => 
		      NodeUtils.getSourceNodeIndex(l) === buildingIndex && 
		      NodeUtils.getTargetNodeIndex(l) === g7Index
		    )?.value || 0;

		    isGasHeating = !isGasHeating;
    
		    this.style.backgroundColor = isGasHeating ? '#BE343D' : '#A9D7F2';
		    this.textContent = isGasHeating ? 'Gas Heat + SHW' : 'HP/Electric Heat+SHW';
    
		    const copHeatingInput = document.getElementById('copHeating');
		    const copHeatingLabel = document.getElementById('copHeatingLabel');
    
		    if (isGasHeating) {
		      previousCOPh = parseFloat(copHeatingInput.value);
		      copHeatingInput.value = 0.98;
		      copHeatingInput.min = 0.5;
		      copHeatingInput.max = 0.99;
		      copHeatingInput.step = 0.01;
		      COPh = 0.98;
		      copHeatingLabel.textContent = 'Heat+SHW Efficiency';
		    } else {
		      copHeatingInput.value = previousCOPh;
		      copHeatingInput.min = 0.1;
		      copHeatingInput.max = 20;
		      copHeatingInput.step = 0.1;
		      COPh = previousCOPh;
		      copHeatingLabel.textContent = 'COP Heating';
		    }

		    // Force HP to remain at current demand
		    HP = currentHP > 0 ? currentHP : HP;
    
		    // Update heat pump values while maintaining demand
		    updateHeatPumpValues(HP);
    
		    // Explicitly restore G7
		    updateLinkSilent(buildingIndex, g7Index, currentG7);
    
		    // Update UI
		    updateValueDisplays();
		    updateSliders();
		    calculateTotalEnergyCost();
    
		    renderChart(false);
		  }
		}
	   ];

	   // Initialize Event Listeners
	   function initializeEventListeners() {
	    eventBindings.forEach(({ id, event, handler }) => {
	      const element = document.getElementById(id);
	      if (element) {
	        element.addEventListener(event, handler);
	      } else {
	        console.warn(`Element with id '${id}' not found for ${event} event binding`);
	      }
	    });

	    window.addEventListener('resize', resizeSankey);
	   }

	   // Resize Handler
	   function resizeSankey() {
	    const width = document.querySelector('.diagram-container').clientWidth;
	    d3.select("#sankey").attr("width", width);
	    sankey.extent([[1, 1], [width - 1, 600 - 1]]);
	    renderChart(false);
	   }

	   // Status Update
	   function updateStatus(message, type = 'pending') {
	    const statusElement = document.getElementById('statusMessage');
	    statusElement.textContent = message;
	    statusElement.className = `status-${type}`;
	   }

	   // Emissions Functions
	   function updateEmissionsFlows() {
	     const scope1NodeIndex = NodeUtils.findNodeIndex("E1 Scope 1 Emissions");
	     const scope2NodeIndex = NodeUtils.findNodeIndex("E2 Scope 2 Emissions");
  
	     // Remove existing emissions flows
	     data.links = data.links.filter(link => {
	       const targetIdx = NodeUtils.getTargetNodeIndex(link);
	       return targetIdx !== scope1NodeIndex && targetIdx !== scope2NodeIndex;
	     });

	     if (showEmissions) {
	       const gridIntensity = parseFloat(document.getElementById('gridIntensity').value) || 0;
    
	       // Handle electrical loads (always Scope 2)
	       const electricalSources = ["G.3.1 Plug Light Equipment"];
	       electricalSources.forEach(sourceName => {
	         const nodeIndex = NodeUtils.findNodeIndex(sourceName);
	         if (nodeIndex === -1) return;
      
	         const flowValue = data.links.reduce((sum, link) => {
	           if (NodeUtils.getSourceNodeIndex(link) === nodeIndex) {
	             return sum + link.value;
	           }
	           return sum;
	         }, 0);

	         if (flowValue > 0.1) {
	           const emissionsValue = flowValue * gridIntensity;
	           if (emissionsValue > 0.1) {
	             data.links.push({
	               source: nodeIndex,
	               target: scope2NodeIndex,
	               value: emissionsValue
	             });
	           }
	         }
	       });

	       // Handle heating and DHW
	       const heatingNodes = [
	         { name: isGasHeating ? "Heating Demand" : "M.2.2 Energy Input" },
	         { name: "W.2.D.N SHW Net Demand" }
	       ];

	       heatingNodes.forEach(({ name }) => {
	         const nodeIndex = NodeUtils.findNodeIndex(name);
	         if (nodeIndex === -1) return;

	         const flowValue = data.links.reduce((sum, link) => {
	           if (NodeUtils.getSourceNodeIndex(link) === nodeIndex) {
	             return sum + link.value;
	           }
	           return sum;
	         }, 0);

	         if (flowValue > 0.1) {
	           const emissionsValue = isGasHeating ?
	             (flowValue / GAS_ENERGY_DENSITY) * GAS_EMISSIONS_INTENSITY :
	             flowValue * gridIntensity;

	           if (emissionsValue > 0.1) {
	             data.links.push({
	               source: nodeIndex,
	               target: isGasHeating ? scope1NodeIndex : scope2NodeIndex,
	               value: emissionsValue
	             });
	           }
	         }
	       });
	     }
	   }

	   function updateEmissionNodeName() {
	     const emissionsNode = data.nodes[data.nodes.length - 1];
	     emissionsNode.name = isGasHeating ? "E1 Scope 1 Emissions" : "E2 Scope 2 Emissions";
	   }

	   // Application Initialization
	   function init() {
	    try {
	      COPh = parseFloat(document.getElementById('copHeating').value) || 3.0;
	      COPc = parseFloat(document.getElementById('copCooling').value) || 4.0;
	      DWHR = parseFloat(document.getElementById('dwhrEfficiency').value) || 0.50;
	      MVHR = parseFloat(document.getElementById('mvhrEfficiency').value) || 0.80;

	      NodeUtils.ensureNodeReferences();
   
	      // Initialize diagram and controls
	      const container = document.querySelector('.diagram-container');
	      const width = container.clientWidth;
	      sankey.extent([[1, 1], [width - 1, 600 - 1]]);
	      d3.select("#sankey").attr("width", width);

	      updateDWHR(DWHR);
	      updateMVHR(MVHR);
	      updateBuildingBalance();
   
	      initializeControls();
	      initializeEventListeners();
	      renderChart(true);
	      calculateTotalEnergyCost();

	      const balance = EnergyCalculator.calculateEnergyBalance();
	      updateStatus(
	        balance.isBalanced ? 'Diagram ready - Energy balanced' : 'Diagram ready - Check energy balance',
	        balance.isBalanced ? 'success' : 'warning'
	      );
	    } catch (error) {
	      console.error("Initialization error:", error);
	      updateStatus('Initialization error: ' + error.message, 'error');
	    }
	   }

	   // Start the application
	   init();
	   //Copyright OpenBuilding.ca 2024. All rights reserved. See Terms and Conditions at https://openbuilding.ca/about/terms-of-use/
	   //NOTES - December 12 2024 - Fixed CSV Handling and trigger updates- next map XLSX functionality to replace default values as one of three value      states. 
	   </script>
	   </body>
	   </html>
